'use strict';

var utils = require('@kobalte/utils');
var store = require('solid-js/store');
var web = require('solid-js/web');
var solidJs = require('solid-js');
var message = require('@internationalized/message');
var dom = require('@floating-ui/dom');
var number = require('@internationalized/number');
var date = require('@internationalized/date');

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode-context.ts
 */
const ColorModeContext = solidJs.createContext();

/**
 * Primitive that reads from `ColorModeProvider` context,
 * Returns the color mode and function to toggle it.
 */
function useColorMode() {
  const context = solidJs.useContext(ColorModeContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useColorMode` must be used within a `ColorModeProvider`");
  }
  return context;
}

/**
 * Change value based on color mode.
 *
 * @param light the light mode value
 * @param dark the dark mode value
 * @return A memoized value based on the color mode.
 *
 * @example
 *
 * ```js
 * const Icon = useColorModeValue(MoonIcon, SunIcon)
 * ```
 */
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return solidJs.createMemo(() => colorMode() === "dark" ? dark : light);
}

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/storage-manager.ts
 */
const COLOR_MODE_STORAGE_KEY = "kb-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get: fallback => {
      if (web.isServer) {
        return fallback;
      }
      let value;
      try {
        value = localStorage.getItem(key);
      } catch (e) {
        // noop
      }
      return value ?? fallback;
    },
    set: value => {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        // noop
      }
    }
  };
}
const localStorageManager = createLocalStorageManager(COLOR_MODE_STORAGE_KEY);
function parseCookie(cookie, key) {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match?.[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get: fallback => {
      if (cookie) {
        return parseCookie(cookie, key) ?? fallback;
      }
      if (web.isServer) {
        return fallback;
      }
      return parseCookie(document.cookie, key) ?? fallback;
    },
    set: value => {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
const cookieStorageManager = createCookieStorageManager(COLOR_MODE_STORAGE_KEY);
function cookieStorageManagerSSR(cookie) {
  return createCookieStorageManager(COLOR_MODE_STORAGE_KEY, cookie);
}

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode.utils.ts
 */
const FALLBACK_COLOR_MODE_VALUE = "system";
function query() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function preventTransition() {
  const css = document.createElement("style");
  css.appendChild(document.createTextNode(`*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`));
  document.head.appendChild(css);
  return () => {
    // force a reflow
    (() => window.getComputedStyle(document.body))();

    // wait for next tick
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css);
      });
    });
  };
}
function setColorModeDataset(value, shouldPreventTransition = true) {
  const cleanup = shouldPreventTransition ? preventTransition() : undefined;
  document.documentElement.dataset.kbTheme = value;
  document.documentElement.style.colorScheme = value;
  cleanup?.();
}
function getSystemColorMode(fallback) {
  const isDark = query().matches ?? fallback === "dark";
  return isDark ? "dark" : "light";
}
function getInitialColorMode(manager) {
  const fallback = "light";
  const initialColorMode = manager.get(fallback) ?? fallback;
  if (initialColorMode === "system") {
    // We can't know the client system preference in SSR so just return the fallback.
    return web.isServer ? fallback : getSystemColorMode();
  }
  return initialColorMode;
}
function addColorModeListener(fn) {
  const mql = query();
  const listener = e => {
    fn(e.matches ? "dark" : "light");
  };
  mql.addEventListener("change", listener);
  return () => {
    mql.removeEventListener("change", listener);
  };
}

/**
 * Provides context for the color mode based on config in `theme`
 * Returns the color mode and function to toggle the color mode
 */
function ColorModeProvider(props) {
  const fallbackColorMode = () => props.initialColorMode ?? FALLBACK_COLOR_MODE_VALUE;
  const colorModeManager = () => props.storageManager ?? localStorageManager;
  let colorModeListenerCleanupFn;
  const [colorMode, rawSetColorMode] = solidJs.createSignal(getInitialColorMode(colorModeManager()));
  const applyColorMode = value => {
    rawSetColorMode(value);
    setColorModeDataset(value, props.disableTransitionOnChange);
  };
  const setColorMode = value => {
    if (colorModeListenerCleanupFn) {
      colorModeListenerCleanupFn();
      colorModeListenerCleanupFn = undefined;
    }
    const isSystem = value === "system";
    if (isSystem) {
      colorModeListenerCleanupFn = addColorModeListener(applyColorMode);
    }
    applyColorMode(isSystem ? getSystemColorMode() : value);
    colorModeManager().set(value);
  };
  const toggleColorMode = () => {
    setColorMode(colorMode() === "dark" ? "light" : "dark");
  };
  solidJs.createEffect(() => {
    setColorMode(colorModeManager().get() ?? fallbackColorMode());
  });
  solidJs.onCleanup(() => {
    // ensure listener is always cleaned when component is destroyed.
    colorModeListenerCleanupFn?.();
  });
  const context = {
    colorMode,
    setColorMode,
    toggleColorMode
  };
  return web.createComponent(ColorModeContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

const _tmpl$$b = /*#__PURE__*/web.template(`<script id="kb-color-mode-script">`);
const VALID_VALUES = new Set(["light", "dark", "system"]);

/**
 * runtime safe-guard against invalid color mode values
 */
function normalize(initialColorMode) {
  if (!VALID_VALUES.has(initialColorMode)) {
    return FALLBACK_COLOR_MODE_VALUE;
  }
  return initialColorMode;
}
function ColorModeScript(props) {
  props = solidJs.mergeProps({
    initialColorMode: FALLBACK_COLOR_MODE_VALUE,
    storageType: "localStorage",
    storageKey: COLOR_MODE_STORAGE_KEY
  }, props);
  const scriptSrc = solidJs.createMemo(() => {
    // runtime safe-guard against invalid color mode values
    const init = normalize(props.initialColorMode);
    const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,s=e==="dark";return d.style.colorScheme=e,d.dataset.kbTheme=e,o},u=a,h="${init}",r="${props.storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();`;
    const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,i=r==="dark";return o.style.colorScheme=r,o.dataset.kbTheme=r,c},n=a,m="${init}",e="${props.storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();`;
    const fn = props.storageType === "cookie" ? cookieScript : localStorageScript;
    return `!${fn}`.trim();
  });

  // eslint-disable-next-line solid/no-innerhtml
  return (() => {
    const _el$ = _tmpl$$b();
    web.effect(_p$ => {
      const _v$ = props.nonce,
        _v$2 = scriptSrc();
      _v$ !== _p$._v$ && web.setAttribute(_el$, "nonce", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && (_el$.innerHTML = _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });
    return _el$;
  })();
}

/**
 * Generate a flatted array of `CollectionNode` from a custom data source.
 */
function buildNodes(params) {
  let index = params.startIndex ?? 0;
  const level = params.startLevel ?? 0;
  const nodes = [];
  const getKey = data => {
    const _getKey = params.getKey ?? "key";
    const dataKey = utils.isString(_getKey) ? data[_getKey] : _getKey(data);
    return dataKey != null ? String(dataKey) : "";
  };
  const getTextValue = data => {
    const _getTextValue = params.getTextValue ?? "textValue";
    const dataTextValue = utils.isString(_getTextValue) ? data[_getTextValue] : _getTextValue(data);
    return dataTextValue != null ? String(dataTextValue) : "";
  };
  const getDisabled = data => {
    const _getDisabled = params.getDisabled ?? "disabled";
    return (utils.isString(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;
  };
  const getSectionChildren = data => {
    if (utils.isString(params.getSectionChildren)) {
      return data[params.getSectionChildren];
    }
    return params.getSectionChildren?.(data);
  };
  for (const data of params.dataSource) {
    // If it's not an object assume it's an item.
    if (utils.isString(data) || utils.isNumber(data)) {
      nodes.push({
        type: "item",
        rawValue: data,
        key: String(data),
        textValue: String(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
      continue;
    }

    // Assume it's a section if it has children.
    if (getSectionChildren(data) != null) {
      nodes.push({
        type: "section",
        rawValue: data,
        key: "",
        // not applicable here
        textValue: "",
        // not applicable here
        disabled: false,
        // not applicable here
        level: level,
        index: index
      });
      index++;
      const sectionChildren = getSectionChildren(data) ?? [];
      if (sectionChildren.length > 0) {
        const childNodes = buildNodes({
          dataSource: sectionChildren,
          getKey: params.getKey,
          getTextValue: params.getTextValue,
          getDisabled: params.getDisabled,
          getSectionChildren: params.getSectionChildren,
          startIndex: index,
          startLevel: level + 1
        });
        nodes.push(...childNodes);
        index += childNodes.length;
      }
    } else {
      nodes.push({
        type: "item",
        rawValue: data,
        key: getKey(data),
        textValue: getTextValue(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
    }
  }
  return nodes;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/collections/src/useCollection.ts
 */
function createCollection(props, deps = []) {
  const initialNodes = buildNodes({
    dataSource: utils.access(props.dataSource),
    getKey: utils.access(props.getKey),
    getTextValue: utils.access(props.getTextValue),
    getDisabled: utils.access(props.getDisabled),
    getSectionChildren: utils.access(props.getSectionChildren)
  });
  const [collection, setCollection] = solidJs.createSignal(props.factory(initialNodes));
  solidJs.createEffect(solidJs.on([() => utils.access(props.dataSource), () => utils.access(props.getKey), () => utils.access(props.getTextValue), () => utils.access(props.getDisabled), () => utils.access(props.getSectionChildren), () => props.factory, ...deps], ([dataSource, getKey, getTextValue, getDisabled, getSectionChildren, factory]) => {
    const nodes = buildNodes({
      dataSource,
      getKey,
      getTextValue,
      getDisabled,
      getSectionChildren
    });
    setCollection(() => factory(nodes));
  }, {
    defer: true
  }));
  return collection;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/22cb32d329e66c60f55d4fc4025d1d44bb015d71/packages/@react-stately/collections/src/getItemCount.ts
 */

const cache$2 = new WeakMap();
function getItemCount(collection) {
  let count = cache$2.get(collection);
  if (count != null) {
    return count;
  }
  count = 0;
  for (const item of collection) {
    if (item.type === "item") {
      count++;
    }
  }
  cache$2.set(collection, count);
  return count;
}

/**
 * Creates a simple reactive state with a getter and setter,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSignal(props) {
  // Internal uncontrolled value
  // eslint-disable-next-line solid/reactivity
  const [_value, _setValue] = solidJs.createSignal(props.defaultValue?.());
  const isControlled = solidJs.createMemo(() => props.value?.() !== undefined);
  const value = solidJs.createMemo(() => isControlled() ? props.value?.() : _value());
  const setValue = next => {
    solidJs.untrack(() => {
      const nextValue = utils.accessWith(next, value());
      if (!Object.is(nextValue, value())) {
        if (!isControlled()) {
          _setValue(nextValue);
        }
        props.onChange?.(nextValue);
      }
      return nextValue;
    });
  };
  return [value, setValue];
}

/**
 * Creates a simple reactive Boolean state with a getter, setter and a fallback value of `false`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableBooleanSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? false;
  return [value, setValue];
}

/**
 * Creates a simple reactive Array state with a getter, setter and a fallback value of `[]`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableArraySignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? [];
  return [value, setValue];
}

/**
 * Creates a simple reactive Set state with a getter, setter and a fallback value of `Set()`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSetSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Set();
  return [value, setValue];
}

/**
 * Provides state management for open, close and toggle scenarios.
 * Used to control the "open state" of components like Modal, Drawer, etc.
 */
function createDisclosureState(props = {}) {
  const [isOpen, setIsOpen] = createControllableBooleanSignal({
    value: () => utils.access(props.open),
    defaultValue: () => !!utils.access(props.defaultOpen),
    onChange: value => props.onOpenChange?.(value)
  });
  const open = () => {
    setIsOpen(true);
  };
  const close = () => {
    setIsOpen(false);
  };
  const toggle = () => {
    isOpen() ? close() : open();
  };
  return {
    isOpen,
    setIsOpen,
    open,
    close,
    toggle
  };
}

/**
 * Listens for when the escape key is down on the document.
 */
function createEscapeKeyDown(props) {
  const handleKeyDown = event => {
    if (event.key === utils.EventKey.Escape) {
      props.onEscapeKeyDown?.(event);
    }
  };
  solidJs.createEffect(() => {
    if (utils.access(props.isDisabled)) {
      return;
    }
    const document = props.ownerDocument?.() ?? utils.getDocument();
    document.addEventListener("keydown", handleKeyDown);
    solidJs.onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/dismissable/src/layer-stack.ts
 */
const DATA_TOP_LAYER_ATTR = "data-kb-top-layer";
let originalBodyPointerEvents;
let hasDisabledBodyPointerEvents = false;
const layers = [];
function indexOf(node) {
  return layers.findIndex(layer => layer.node === node);
}
function find(node) {
  return layers[indexOf(node)];
}
function isTopMostLayer(node) {
  return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
  return layers.filter(layer => layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
  return [...getPointerBlockingLayers()].slice(-1)[0];
}
function hasPointerBlockingLayer() {
  return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
  const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
  return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
  layers.push(layer);
}
function removeLayer(node) {
  const index = indexOf(node);
  if (index < 0) {
    return;
  }
  layers.splice(index, 1);
}
function assignPointerEventToLayers() {
  layers.forEach(({
    node
  }) => {
    node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}

/**
 * Disable body `pointer-events` if there are "pointer blocking" layers in the stack,
 * and body `pointer-events` has not been disabled yet.
 */
function disableBodyPointerEvents(node) {
  if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
    const ownerDocument = utils.getDocument(node);
    originalBodyPointerEvents = document.body.style.pointerEvents;
    ownerDocument.body.style.pointerEvents = "none";
    hasDisabledBodyPointerEvents = true;
  }
}

/**
 * Restore body `pointer-events` style if there is no "pointer blocking" layer in the stack.
 */
function restoreBodyPointerEvents(node) {
  if (hasPointerBlockingLayer()) {
    return;
  }
  const ownerDocument = utils.getDocument(node);
  ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
  if (ownerDocument.body.style.length === 0) {
    ownerDocument.body.removeAttribute("style");
  }
  hasDisabledBodyPointerEvents = false;
}
const layerStack = {
  layers,
  isTopMostLayer,
  hasPointerBlockingLayer,
  isBelowPointerBlockingLayer,
  addLayer,
  removeLayer,
  indexOf,
  find,
  assignPointerEventToLayers,
  disableBodyPointerEvents,
  restoreBodyPointerEvents
};

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/focus-scope/src/FocusScope.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-on-child-unmount.ts
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-containment.ts
 */
const AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const focusScopeStack = {
  /** A stack of focus scopes, with the active one at the top */
  stack: [],
  active() {
    return this.stack[0];
  },
  add(scope) {
    // pause the currently active focus scope (at the top of the stack)
    if (scope !== this.active()) {
      this.active()?.pause();
    }

    // remove in case it already exists and re-add it at the top of the stack.
    this.stack = utils.removeItemFromArray(this.stack, scope);
    this.stack.unshift(scope);
  },
  remove(scope) {
    this.stack = utils.removeItemFromArray(this.stack, scope);
    this.active()?.resume();
  }
};
function createFocusScope(props, ref) {
  const [isPaused, setIsPaused] = solidJs.createSignal(false);
  const focusScope = {
    pause() {
      setIsPaused(true);
    },
    resume() {
      setIsPaused(false);
    }
  };
  let lastFocusedElement = null;
  const onMountAutoFocus = e => props.onMountAutoFocus?.(e);
  const onUnmountAutoFocus = e => props.onUnmountAutoFocus?.(e);
  const ownerDocument = () => utils.getDocument(ref());
  const createSentinel = () => {
    const element = ownerDocument().createElement("span");
    element.setAttribute("data-focus-trap", "");
    element.tabIndex = 0;
    Object.assign(element.style, utils.visuallyHiddenStyles);
    return element;
  };
  const tabbables = () => {
    const container = ref();
    if (!container) {
      return [];
    }

    // Get all tabbable in container excluding focus scope sentinels
    return utils.getAllTabbableIn(container, true).filter(el => !el.hasAttribute("data-focus-trap"));
  };
  const firstTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[0] : null;
  };
  const lastTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[items.length - 1] : null;
  };
  const shouldPreventUnmountAutoFocus = () => {
    const container = ref();
    if (!container) {
      return false;
    }
    const activeElement = utils.getActiveElement(container);
    if (!activeElement) {
      return false;
    }
    if (utils.contains(container, activeElement)) {
      return false;
    }

    // Don't autofocus the previously focused element on unmount
    // if a focusable element outside the container is already focused.
    return utils.isFocusable(activeElement);
  };

  // Handle dispatching mount and unmount autofocus events.
  solidJs.createEffect(() => {
    const container = ref();
    if (!container) {
      return;
    }
    focusScopeStack.add(focusScope);
    const previouslyFocusedElement = utils.getActiveElement(container);
    const hasFocusedCandidate = utils.contains(container, previouslyFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
      container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      container.dispatchEvent(mountEvent);
      if (!mountEvent.defaultPrevented) {
        // Delay the focusing because it may run before a `DismissableLayer` is added to the layer stack,
        // so it cause nested dismissable layer to open then close instantly.
        setTimeout(() => {
          utils.focusWithoutScrolling(firstTabbable());
          if (utils.getActiveElement(container) === previouslyFocusedElement) {
            utils.focusWithoutScrolling(container);
          }
        }, 0);
      }
    }
    solidJs.onCleanup(() => {
      container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      setTimeout(() => {
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
        if (shouldPreventUnmountAutoFocus()) {
          unmountEvent.preventDefault();
        }
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          utils.focusWithoutScrolling(previouslyFocusedElement ?? ownerDocument().body);
        }

        // We need to remove the listener after we `dispatchEvent`.
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        focusScopeStack.remove(focusScope);
      }, 0);
    });
  });

  /*
  // Handle containing focus if a child unmount.
  createEffect(() => {
    const container = ref();
     if (!container || !access(props.trapFocus)) {
      return;
    }
     const observer = new MutationObserver(([mutation]) => {
      if (!mutation || mutation.target !== container) {
        return;
      }
       if (getActiveElement(container) === ownerDocument().body) {
        focusWithoutScrolling(container);
      }
    });
     observer.observe(container, { childList: true, subtree: true });
     onCleanup(() => {
      observer.disconnect();
    });
  });
  */

  // Handle containing focus if focus is moved outside.
  solidJs.createEffect(() => {
    const container = ref();
    if (!container || !utils.access(props.trapFocus) || isPaused()) {
      return;
    }
    const onFocusIn = event => {
      const target = event.target;

      // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (utils.contains(container, target)) {
        lastFocusedElement = target;
      } else {
        utils.focusWithoutScrolling(lastFocusedElement);
      }
    };
    const onFocusOut = event => {
      const relatedTarget = event.relatedTarget;
      const target = relatedTarget ?? utils.getActiveElement(container);

      // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (!utils.contains(container, target)) {
        utils.focusWithoutScrolling(lastFocusedElement);
      }
    };
    ownerDocument().addEventListener("focusin", onFocusIn);
    ownerDocument().addEventListener("focusout", onFocusOut);
    solidJs.onCleanup(() => {
      ownerDocument().removeEventListener("focusin", onFocusIn);
      ownerDocument().removeEventListener("focusout", onFocusOut);
    });
  });

  // Handle looping focus (when tabbing whilst at the edges)
  solidJs.createEffect(() => {
    const container = ref();
    if (!container || !utils.access(props.trapFocus) || isPaused()) {
      return;
    }
    const startSentinel = createSentinel();
    container.insertAdjacentElement("afterbegin", startSentinel);
    const endSentinel = createSentinel();
    container.insertAdjacentElement("beforeend", endSentinel);
    function onFocus(event) {
      const first = firstTabbable();
      const last = lastTabbable();
      if (event.relatedTarget === first) {
        utils.focusWithoutScrolling(last);
      } else {
        utils.focusWithoutScrolling(first);
      }
    }
    startSentinel.addEventListener("focusin", onFocus);
    endSentinel.addEventListener("focusin", onFocus);

    // Ensure sentinels are always the edges of the container.
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.previousSibling === endSentinel) {
          endSentinel.remove();
          container.insertAdjacentElement("beforeend", endSentinel);
        }
        if (mutation.nextSibling === startSentinel) {
          startSentinel.remove();
          container.insertAdjacentElement("afterbegin", startSentinel);
        }
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: false
    });
    solidJs.onCleanup(() => {
      startSentinel.removeEventListener("focusin", onFocus);
      endSentinel.removeEventListener("focusin", onFocus);
      startSentinel.remove();
      endSentinel.remove();
      observer.disconnect();
    });
  });
}

/*!
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the zag team:
 * https://github.com/chakra-ui/zag/blob/c1e6c7689b22bf58741ded7cf224dd9baec2a046/packages/utilities/form-utils/src/form.ts
 */

/**
 * Listens for `reset` event on the closest `<form>` element and execute the given handler.
 */
function createFormResetListener(element, handler) {
  solidJs.createEffect(solidJs.on(element, element => {
    if (element == null) {
      return;
    }
    const form = getClosestForm(element);
    if (form == null) {
      return;
    }
    form.addEventListener("reset", handler, {
      passive: true
    });
    solidJs.onCleanup(() => {
      form.removeEventListener("reset", handler);
    });
  }));
}
function getClosestForm(element) {
  return isFormElement(element) ? element.form : element.closest("form");
}
function isFormElement(element) {
  return element.matches("textarea, input, select, button");
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/live-announcer/src/LiveAnnouncer.tsx
 */
/* Inspired by https://github.com/AlmeroSteyn/react-aria-live */
const LIVEREGION_TIMEOUT_DELAY = 7000;
let liveAnnouncer = null;
const DATA_LIVE_ANNOUNCER_ATTR = "data-live-announcer";

/**
 * Announces the message using screen reader technology.
 */
function announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
  if (!liveAnnouncer) {
    liveAnnouncer = new LiveAnnouncer();
  }
  liveAnnouncer.announce(message, assertiveness, timeout);
}

/**
 * Stops all queued announcements.
 */
function clearAnnouncer(assertiveness) {
  if (liveAnnouncer) {
    liveAnnouncer.clear(assertiveness);
  }
}

/**
 * Removes the announcer from the DOM.
 */
function destroyAnnouncer() {
  if (liveAnnouncer) {
    liveAnnouncer.destroy();
    liveAnnouncer = null;
  }
}

// LiveAnnouncer is implemented using vanilla DOM, not SolidJS.
class LiveAnnouncer {
  constructor() {
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, utils.visuallyHiddenStyles);
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
  createLog(ariaLive) {
    const node = document.createElement("div");
    node.setAttribute("role", "log");
    node.setAttribute("aria-live", ariaLive);
    node.setAttribute("aria-relevant", "additions");
    return node;
  }
  destroy() {
    if (!this.node) {
      return;
    }
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node) {
      return;
    }
    const node = document.createElement("div");
    node.textContent = message;
    if (assertiveness === "assertive") {
      this.assertiveLog.appendChild(node);
    } else {
      this.politeLog.appendChild(node);
    }
    if (message !== "") {
      setTimeout(() => {
        node.remove();
      }, timeout);
    }
  }
  clear(assertiveness) {
    if (!this.node) {
      return;
    }
    if (!assertiveness || assertiveness === "assertive") {
      this.assertiveLog.innerHTML = "";
    }
    if (!assertiveness || assertiveness === "polite") {
      this.politeLog.innerHTML = "";
    }
  }
}

/*!
 * This file is based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/810579b671791f1593108f62cdc1893de3a220e3/packages/@react-aria/overlays/src/ariaHideOutside.ts
 */
/**
 * Hides all elements in the DOM outside the given targets from screen readers
 * using aria-hidden, and returns a function to revert these changes.
 * In addition, changes to the DOM are watched and new elements
 * outside the targets are automatically hidden.
 */
function createHideOutside(props) {
  solidJs.createEffect(() => {
    if (utils.access(props.isDisabled)) {
      return;
    }
    solidJs.onCleanup(ariaHideOutside(utils.access(props.targets), utils.access(props.root)));
  });
}
// Keeps a ref count of all hidden elements.
// Added to when hiding an element, and subtracted from when showing it again.
// When it reaches zero, aria-hidden is removed.
const refCountMap = new WeakMap();
const observerStack = [];

/**
 * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,
 * and returns a function to revert these changes. In addition, changes to the DOM are watched
 * and new elements outside the targets are automatically hidden.
 * @param targets - The elements that should remain visible.
 * @param root - Nothing will be hidden above this element.
 * @returns - A function to restore all hidden elements.
 */
function ariaHideOutside(targets, root = document.body) {
  const visibleNodes = new Set(targets);
  const hiddenNodes = new Set();
  const walk = root => {
    // Keep live announcer and top layer elements (e.g. toasts) visible.
    for (const element of root.querySelectorAll(`[${DATA_LIVE_ANNOUNCER_ATTR}], [${DATA_TOP_LAYER_ATTR}]`)) {
      visibleNodes.add(element);
    }
    const acceptNode = node => {
      // Skip this node and its children if it is one of the target nodes, or a live announcer.
      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is
      // made for elements with role="row" since VoiceOver on iOS has issues hiding elements with role="row".
      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }

      // Skip this node but continue to children if one of the targets is inside the node.
      for (const target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });

    // TreeWalker does not include the root.
    const acceptRoot = acceptNode(root);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide(root);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide(node);
        node = walker.nextNode();
      }
    }
  };
  const hide = node => {
    const refCount = refCountMap.get(node) ?? 0;

    // If already aria-hidden, and the ref count is zero, then this element
    // was already hidden and there's nothing for us to do.
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };

  // If there is already a MutationObserver listening from a previous call,
  // disconnect it so the new on takes over.
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  const observer = new MutationObserver(changes => {
    for (const change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }

      // If the parent element of the added nodes is not within one of the targets,
      // and not already inside a hidden node, hide all of the new children.
      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {
        for (const node of change.removedNodes) {
          if (node instanceof Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (const node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.reactAriaTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  const observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (const node of hiddenNodes) {
      const count = refCountMap.get(node);
      if (count == null) {
        return;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }

    // Remove this observer from the stack, and start the previous one.
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/interact-outside/src/index.ts
 */
const POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
const FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
  let pointerDownTimeoutId;
  let clickHandler = utils.noop;
  const ownerDocument = () => utils.getDocument(ref());
  const onPointerDownOutside = e => props.onPointerDownOutside?.(e);
  const onFocusOutside = e => props.onFocusOutside?.(e);
  const onInteractOutside = e => props.onInteractOutside?.(e);
  const isEventOutside = e => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) {
      return false;
    }

    // If the target is within a top layer element (e.g. toasts), ignore.
    if (target.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
      return false;
    }
    if (!utils.contains(ownerDocument(), target)) {
      return false;
    }
    if (utils.contains(ref(), target)) {
      return false;
    }
    return !props.shouldExcludeElement?.(target);
  };
  const onPointerDown = e => {
    function handler() {
      const container = ref();
      const target = e.target;
      if (!container || !target || !isEventOutside(e)) {
        return;
      }
      const handler = utils.composeEventHandlers([onPointerDownOutside, onInteractOutside]);
      target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler, {
        once: true
      });
      const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: e,
          isContextMenu: e.button === 2 || utils.isCtrlKey(e) && e.button === 0
        }
      });
      target.dispatchEvent(pointerDownOutsideEvent);
    }

    /**
     * On touch devices, we need to wait for a click event because browsers implement
     * a ~350ms delay between the time the user stops touching the display and when the
     * browser executes events. We need to ensure we don't reactivate pointer-events within
     * this timeframe otherwise the browser may execute events that should have been prevented.
     *
     * Additionally, this also lets us deal automatically with cancellations when a click event
     * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.
     *
     * This is why we also continuously remove the previous listener, because we cannot be
     * certain that it was raised, and therefore cleaned-up.
     */
    if (e.pointerType === "touch") {
      ownerDocument().removeEventListener("click", handler);
      clickHandler = handler;
      ownerDocument().addEventListener("click", handler, {
        once: true
      });
    } else {
      handler();
    }
  };
  const onFocusIn = e => {
    const container = ref();
    const target = e.target;
    if (!container || !target || !isEventOutside(e)) {
      return;
    }
    const handler = utils.composeEventHandlers([onFocusOutside, onInteractOutside]);
    target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
      once: true
    });
    const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: e,
        isContextMenu: false
      }
    });
    target.dispatchEvent(focusOutsideEvent);
  };
  solidJs.createEffect(() => {
    if (utils.access(props.isDisabled)) {
      return;
    }

    /**
     * if this primitive executes in a component that mounts via a `pointerdown` event, the event
     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid
     * this by delaying the event listener registration on the document.
     * ```
     * button.addEventListener('pointerdown', () => {
     *   console.log('I will log');
     *   document.addEventListener('pointerdown', () => {
     *     console.log('I will also log');
     *   })
     * });
     */
    pointerDownTimeoutId = window.setTimeout(() => {
      ownerDocument().addEventListener("pointerdown", onPointerDown, true);
    }, 0);
    ownerDocument().addEventListener("focusin", onFocusIn, true);
    solidJs.onCleanup(() => {
      window.clearTimeout(pointerDownTimeoutId);
      ownerDocument().removeEventListener("click", clickHandler);
      ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
      ownerDocument().removeEventListener("focusin", onFocusIn, true);
    });
  });
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/Presence.tsx
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/useStateMachine.tsx
 */
function createPresence(present) {
  const [node, setNode] = solidJs.createSignal();
  let styles = {};
  let prevPresent = present();
  let prevAnimationName = "none";
  const [state, send] = createStateMachine(present() ? "mounted" : "unmounted", {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  solidJs.createEffect(solidJs.on(state, state => {
    const currentAnimationName = getAnimationName(styles);
    prevAnimationName = state === "mounted" ? currentAnimationName : "none";
  }));
  solidJs.createEffect(solidJs.on(present, present => {
    if (prevPresent === present) {
      return;
    }
    const currentAnimationName = getAnimationName(styles);
    if (present) {
      send("MOUNT");
      //} else if (currentAnimationName === "none" || styles?.display === "none") {
      // If there is no exit animation or the element is hidden, animations won't run, so we unmount instantly
    } else if (styles?.display === "none") {
      // If the element is hidden, animations won't run, so we unmount instantly
      send("UNMOUNT");
    } else {
      /**
       * When `present` changes to `false`, we check changes to animation-name to
       * determine whether an animation has started. We chose this approach (reading
       * computed styles) because there is no `animationrun` event and `animationstart`
       * fires after `animation-delay` has expired which would be too late.
       */
      const isAnimating = prevAnimationName !== currentAnimationName;
      if (prevPresent && isAnimating) {
        send("ANIMATION_OUT");
      } else {
        send("UNMOUNT");
      }
    }
    prevPresent = present;
  }));
  solidJs.createEffect(solidJs.on(node, node => {
    if (node) {
      /**
       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
       * make sure we only trigger ANIMATION_END for the currently active animation.
       */
      const handleAnimationEnd = event => {
        const currentAnimationName = getAnimationName(styles);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
        }
      };
      const handleAnimationStart = event => {
        if (event.target === node) {
          // if animation occurred, store its name as the previous animation.
          prevAnimationName = getAnimationName(styles);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      solidJs.onCleanup(() => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      });
    } else {
      // Transition to the unmounted state if the node is removed prematurely.
      // We avoid doing so during cleanup as the node may change but still exist.
      send("ANIMATION_END");
    }
  }));
  return {
    isPresent: () => ["mounted", "unmountSuspended"].includes(state()),
    setRef: el => {
      if (el) {
        styles = getComputedStyle(el);
      }
      setNode(el);
    }
  };
}

/* -----------------------------------------------------------------------------------------------*/

function getAnimationName(styles) {
  return styles?.animationName || "none";
}

// https://fettblog.eu/typescript-union-to-intersection/

function createStateMachine(initialState, machine) {
  const reduce = (state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  };
  const [state, setState] = solidJs.createSignal(initialState);
  const send = event => {
    setState(prev => reduce(prev, event));
  };
  return [state, send];
}

/*!
 * Portions of this file are based on code from floating-ui.
 * MIT Licensed, Copyright (c) 2021 Floating UI contributors.
 *
 * Credits to the Floating UI contributors:
 * https://github.com/floating-ui/floating-ui/blob/f7ce9420aa32c150eb45049f12cf3b5506715341/packages/react/src/components/FloatingOverlay.tsx
 *
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/5d8a1f047fcadcf117073c70359663a3946b73bf/packages/ariakit/src/dialog/__utils/use-prevent-body-scroll.ts
 */
const SCROLL_LOCK_IDENTIFIER = "data-kb-scroll-lock";
function assignStyle(element, style) {
  if (!element) {
    return () => {};
  }
  const previousStyle = element.style.cssText;
  Object.assign(element.style, style);
  return () => {
    element.style.cssText = previousStyle;
  };
}
function setCSSProperty(element, property, value) {
  if (!element) {
    return () => {};
  }
  const previousValue = element.style.getPropertyValue(property);
  element.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      element.style.setProperty(property, previousValue);
    } else {
      element.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  // RTL <body> scrollbar
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
/**
 * Prevents scrolling on the document body on mount, and
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */
function createPreventScroll(props) {
  solidJs.createEffect(() => {
    if (!utils.access(props.ownerRef) || utils.access(props.isDisabled)) {
      return;
    }
    const doc = utils.getDocument(utils.access(props.ownerRef));
    const win = utils.getWindow(utils.access(props.ownerRef));
    const {
      documentElement,
      body
    } = doc;
    const alreadyLocked = body.hasAttribute(SCROLL_LOCK_IDENTIFIER);
    if (alreadyLocked) {
      return;
    }
    body.setAttribute(SCROLL_LOCK_IDENTIFIER, "");
    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
    const setScrollbarWidthProperty = () => {
      return setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
    };
    const paddingProperty = getPaddingProperty(documentElement);

    // For most browsers, all we need to do is set `overflow: hidden` on the root element, and
    // add some padding to prevent the page from shifting when the scrollbar is hidden.
    const setStyle = () => {
      return assignStyle(body, {
        overflow: "hidden",
        [paddingProperty]: `${scrollbarWidth}px`
      });
    };

    // Only iOS doesn't respect `overflow: hidden` on document.body.
    const setIOSStyle = () => {
      const {
        scrollX,
        scrollY,
        visualViewport
      } = win;

      // iOS 12 does not support `visualViewport`.
      const offsetLeft = visualViewport?.offsetLeft ?? 0;
      const offsetTop = visualViewport?.offsetTop ?? 0;
      const restoreStyle = assignStyle(body, {
        position: "fixed",
        overflow: "hidden",
        top: `${-(scrollY - Math.floor(offsetTop))}px`,
        left: `${-(scrollX - Math.floor(offsetLeft))}px`,
        right: "0",
        [paddingProperty]: `${scrollbarWidth}px`
      });
      return () => {
        restoreStyle();
        win.scrollTo(scrollX, scrollY);
      };
    };
    const cleanup = utils.chain([setScrollbarWidthProperty(), utils.isIOS() ? setIOSStyle() : setStyle()]);
    solidJs.onCleanup(() => {
      cleanup();
      body.removeAttribute(SCROLL_LOCK_IDENTIFIER);
    });
  });
}

/**
 * Create a function that call the setter with an id and return a function to reset it.
 */
function createRegisterId(setter) {
  return id => {
    setter(id);
    return () => setter(undefined);
  };
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/ariakit/ariakit/blob/8a13899ff807bbf39f3d89d2d5964042ba4d5287/packages/ariakit-react-utils/src/hooks.ts
 */

/**
 * Returns the tag name by parsing an element ref.
 * @example
 * function Component(props) {
 *   let ref: HTMLDivElement | undefined;
 *   const tagName = createTagName(() => ref, () => "button"); // div
 *   return <div ref={ref} {...props} />;
 * }
 */
function createTagName(ref, fallback) {
  const [tagName, setTagName] = solidJs.createSignal(stringOrUndefined(fallback?.()));
  solidJs.createEffect(() => {
    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
  });
  return tagName;
}
function stringOrUndefined(value) {
  return utils.isString(value) ? value : undefined;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a13802d8be6f83af1450e56f7a88527b10d9cadf/packages/@react-stately/toggle/src/useToggleState.ts
 */
/**
 * Provides state management for toggle components like checkboxes and switches.
 */
function createToggleState(props = {}) {
  const [isSelected, _setIsSelected] = createControllableBooleanSignal({
    value: () => utils.access(props.isSelected),
    defaultValue: () => !!utils.access(props.defaultIsSelected),
    onChange: value => props.onSelectedChange?.(value)
  });
  const setIsSelected = value => {
    if (!utils.access(props.isReadOnly) && !utils.access(props.isDisabled)) {
      _setIsSelected(value);
    }
  };
  const toggle = () => {
    if (!utils.access(props.isReadOnly) && !utils.access(props.isDisabled)) {
      _setIsSelected(!isSelected());
    }
  };
  return {
    isSelected,
    setIsSelected,
    toggle
  };
}

/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/get-transition-styles/get-transition-styles.ts
 */

const TRANSITION_PHASES_MAP = {
  beforeEnter: "out",
  enter: "in",
  afterEnter: "in",
  beforeExit: "in",
  //"out",
  exit: "out",
  afterExit: "out"
};
function getTransitionStyles(params) {
  const shared = {
    "transition-duration": `${params.duration}ms`,
    "transition-timing-function": params.easing
  };
  return {
    "transition-property": getTransitionProperty(params.transition),
    ...shared,
    ...params.transition.common,
    ...params.transition[TRANSITION_PHASES_MAP[params.phase]]
  };
}
function getTransitionProperty(transitionStyles) {
  return [...new Set([...Object.keys(transitionStyles.in), ...Object.keys(transitionStyles.out)])].join(", ");
}

/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/use-transition.ts
 */
const DEFAULT_DURATION = 250;
const DEFAULT_DELAY = 10;
const DEFAULT_EASING = "ease";

/**
 * Primitive for working with enter/exit transitions.
 *
 * @param shouldMount Whether the component should be mounted.
 * @param options The transition options.
 */
function createTransition(shouldMount, options) {
  options = solidJs.mergeProps({
    duration: DEFAULT_DURATION,
    delay: DEFAULT_DELAY,
    easing: DEFAULT_EASING,
    get exitDuration() {
      return utils.access(options).duration || DEFAULT_DURATION;
    },
    get exitDelay() {
      return utils.access(options).delay || DEFAULT_DELAY;
    },
    get exitEasing() {
      return utils.access(options).easing || DEFAULT_EASING;
    }
  }, options);
  const reduceMotion = utils.createMediaQuery("(prefers-reduced-motion: reduce)");
  const [duration, setDuration] = solidJs.createSignal(reduceMotion() ? 0 : utils.access(options).duration);
  const [phase, setPhase] = solidJs.createSignal(utils.access(shouldMount) ? "afterEnter" : "afterExit");
  const [easing, setEasing] = solidJs.createSignal(utils.access(options).easing);
  let timeoutId = -1;
  const handleStateChange = shouldMount => {
    const preHandler = shouldMount ? utils.access(options).onBeforeEnter : utils.access(options).onBeforeExit;
    const postHandler = shouldMount ? utils.access(options).onAfterEnter : utils.access(options).onAfterExit;
    setPhase(shouldMount ? "beforeEnter" : "beforeExit");
    window.clearTimeout(timeoutId);
    const newDuration = setDuration(reduceMotion() ? 0 : shouldMount ? utils.access(options).duration : utils.access(options).exitDuration);
    setEasing(shouldMount ? utils.access(options).easing : utils.access(options).exitEasing);
    if (newDuration === 0) {
      preHandler?.();
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
      return;
    }
    const delay = reduceMotion() ? 0 : shouldMount ? utils.access(options).delay : utils.access(options).exitDelay;
    const preStateTimeoutId = window.setTimeout(() => {
      preHandler?.();
      setPhase(shouldMount ? "enter" : "exit");
    }, delay);
    timeoutId = window.setTimeout(() => {
      window.clearTimeout(preStateTimeoutId);
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
    }, delay + newDuration);
  };
  const style = solidJs.createMemo(() => getTransitionStyles({
    transition: utils.access(options).transition,
    duration: duration(),
    phase: phase(),
    easing: easing()
  }));
  const keepMounted = solidJs.createMemo(() => phase() !== "afterExit");
  solidJs.createEffect(solidJs.on(() => utils.access(shouldMount), shouldMount => handleStateChange(shouldMount), {
    defer: true
  }));
  solidJs.onCleanup(() => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(timeoutId);
  });
  return {
    keepMounted,
    style
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/70e7caf1946c423bc9aa9cb0e50dbdbe953d239b/packages/@react-aria/label/src/useField.ts
 */
const FORM_CONTROL_PROP_NAMES = ["id", "name", "validationState", "required", "disabled", "readOnly"];
function createFormControl(props) {
  const defaultId = `form-control-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [fieldId, setFieldId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [errorMessageId, setErrorMessageId] = solidJs.createSignal();
  const getAriaLabelledBy = (fieldId, fieldAriaLabel, fieldAriaLabelledBy) => {
    const hasAriaLabelledBy = fieldAriaLabelledBy != null || labelId() != null;
    return [fieldAriaLabelledBy, labelId(),
    // If there is both an aria-label and aria-labelledby, add the field itself has an aria-labelledby
    hasAriaLabelledBy && fieldAriaLabel != null ? fieldId : undefined].filter(Boolean).join(" ") || undefined;
  };
  const getAriaDescribedBy = fieldAriaDescribedBy => {
    return [descriptionId(),
    // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA.
    // See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
    errorMessageId(), fieldAriaDescribedBy].filter(Boolean).join(" ") || undefined;
  };
  const dataset = solidJs.createMemo(() => ({
    "data-valid": utils.access(props.validationState) === "valid" ? "" : undefined,
    "data-invalid": utils.access(props.validationState) === "invalid" ? "" : undefined,
    "data-required": utils.access(props.required) ? "" : undefined,
    "data-disabled": utils.access(props.disabled) ? "" : undefined,
    "data-readonly": utils.access(props.readOnly) ? "" : undefined
  }));
  const formControlContext = {
    name: () => utils.access(props.name) ?? utils.access(props.id),
    dataset,
    validationState: () => utils.access(props.validationState),
    isRequired: () => utils.access(props.required),
    isDisabled: () => utils.access(props.disabled),
    isReadOnly: () => utils.access(props.readOnly),
    labelId,
    fieldId,
    descriptionId,
    errorMessageId,
    getAriaLabelledBy,
    getAriaDescribedBy,
    generateId: utils.createGenerateId(() => utils.access(props.id)),
    registerLabel: createRegisterId(setLabelId),
    registerField: createRegisterId(setFieldId),
    registerDescription: createRegisterId(setDescriptionId),
    registerErrorMessage: createRegisterId(setErrorMessageId)
  };
  return {
    formControlContext
  };
}

const FormControlContext = solidJs.createContext();
function useFormControlContext() {
  const context = solidJs.useContext(FormControlContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useFormControlContext` must be used within a `FormControlContext.Provider` component");
  }
  return context;
}

const FORM_CONTROL_FIELD_PROP_NAMES = ["id", "aria-label", "aria-labelledby", "aria-describedby"];
function createFormControlField(props) {
  const context = useFormControlContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("field")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerField(utils.access(props.id))));
  return {
    fieldProps: {
      id: () => utils.access(props.id),
      ariaLabel: () => utils.access(props["aria-label"]),
      ariaLabelledBy: () => context.getAriaLabelledBy(utils.access(props.id), utils.access(props["aria-label"]), utils.access(props["aria-labelledby"])),
      ariaDescribedBy: () => context.getAriaDescribedBy(utils.access(props["aria-describedby"]))
    }
  };
}

/* -------------------------------------------------------------------------------------------------
 * Polymorphic
 * -----------------------------------------------------------------------------------------------*/

/**
 * A utility component that render either a direct `<As>` child or its `as` prop.
 */
function Polymorphic(props) {
  const [local, others] = solidJs.splitProps(props, ["asChild", "as", "children"]);

  // Prevent the extra computation below when "as child" polymorphism is not needed.
  if (!local.asChild) {
    return web.createComponent(web.Dynamic, web.mergeProps({
      get component() {
        return local.as;
      }
    }, others, {
      get children() {
        return local.children;
      }
    }));
  }
  const resolvedChildren = solidJs.children(() => local.children);

  // Single child is `As`.
  if (isAs(resolvedChildren())) {
    const combinedProps = combineProps(others, resolvedChildren()?.props ?? {});
    return web.createComponent(web.Dynamic, combinedProps);
  }

  // Multiple children, find an `As` if any.
  if (utils.isArray(resolvedChildren())) {
    const newElement = resolvedChildren().find(isAs);
    if (newElement) {
      // because the new element will be the one rendered, we are only interested
      // in grabbing its children (`newElement.props.children`)
      const newChildren = () => web.createComponent(solidJs.For, {
        get each() {
          return resolvedChildren();
        },
        children: child => web.createComponent(solidJs.Show, {
          when: child === newElement,
          fallback: child,
          get children() {
            return newElement.props.children;
          }
        })
      });
      const combinedProps = combineProps(others, newElement?.props ?? {});
      return web.createComponent(web.Dynamic, web.mergeProps(combinedProps, {
        children: newChildren
      }));
    }
  }
  throw new Error("[kobalte]: Component is expected to render `asChild` but no children `As` component was found.");
}

/* -------------------------------------------------------------------------------------------------
 * As
 * -----------------------------------------------------------------------------------------------*/

const AS_COMPONENT_SYMBOL = Symbol("$$KobalteAsComponent");

/**
 * A utility component used to delegate rendering of its `Polymorphic` parent component.
 */
function As(props) {
  return {
    [AS_COMPONENT_SYMBOL]: true,
    props
  };
}

/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/

function isAs(component) {
  return component?.[AS_COMPONENT_SYMBOL] === true;
}
function combineProps(baseProps, overrideProps) {
  return utils.combineProps([baseProps, overrideProps], {
    reverseEventHandlers: true
  });
}

/**
 * The description that gives the user more information on the form control.
 */
function FormControlDescription(props) {
  const context = useFormControlContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(props.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), props));
}

/**
 * The error message that gives the user information about how to fix a validation error on the form control.
 */
function FormControlErrorMessage(props) {
  const context = useFormControlContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("error-message")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["forceMount"]);
  const isInvalid = () => context.validationState() === "invalid";
  solidJs.createEffect(() => {
    if (!isInvalid()) {
      return;
    }
    solidJs.onCleanup(context.registerErrorMessage(others.id));
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || isInvalid();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

/**
 * The label that gives the user information on the form control.
 */
function FormControlLabel(props) {
  let ref;
  const context = useFormControlContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  const tagName = createTagName(() => ref, () => "label");
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(others.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "label",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["for"]() {
      return web.memo(() => tagName() === "label")() ? context.fieldId() : undefined;
    }
  }, () => context.dataset(), others));
}

const COMMON_INTL_MESSAGES = {
  "ar-AE": {
    dismiss: ""
  },
  "bg-BG": {
    dismiss: ""
  },
  "cs-CZ": {
    dismiss: "Odstranit"
  },
  "da-DK": {
    dismiss: "Luk"
  },
  "de-DE": {
    dismiss: "Schlieen"
  },
  "el-GR": {
    dismiss: ""
  },
  "en-US": {
    dismiss: "Dismiss"
  },
  "es-ES": {
    dismiss: "Descartar"
  },
  "et-EE": {
    dismiss: "Lpeta"
  },
  "fi-FI": {
    dismiss: "Hylk"
  },
  "fr-FR": {
    dismiss: "Rejeter"
  },
  "he-IL": {
    dismiss: ""
  },
  "hr-HR": {
    dismiss: "Odbaci"
  },
  "hu-HU": {
    dismiss: "Elutasts"
  },
  "it-IT": {
    dismiss: "Ignora"
  },
  "ja-JP": {
    dismiss: ""
  },
  "ko-KR": {
    dismiss: ""
  },
  "lt-LT": {
    dismiss: "Atmesti"
  },
  "lv-LV": {
    dismiss: "Nerdt"
  },
  "nb-NO": {
    dismiss: "Lukk"
  },
  "nl-NL": {
    dismiss: "Negeren"
  },
  "pl-PL": {
    dismiss: "Zignoruj"
  },
  "pt-BR": {
    dismiss: "Descartar"
  },
  "pt-PT": {
    dismiss: "Dispensar"
  },
  "ro-RO": {
    dismiss: "Revocare"
  },
  "ru-RU": {
    dismiss: ""
  },
  "sk-SK": {
    dismiss: "Zrui"
  },
  "sl-SI": {
    dismiss: "Opusti"
  },
  "sr-SP": {
    dismiss: "Odbaci"
  },
  "sv-SE": {
    dismiss: "Avvisa"
  },
  "tr-TR": {
    dismiss: "Kapat"
  },
  "uk-UA": {
    dismiss: ""
  },
  "zh-CN": {
    dismiss: ""
  },
  "zh-TW": {
    dismiss: ""
  }
};

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/utils.ts
 */

// https://en.wikipedia.org/wiki/Right-to-left
const RTL_SCRIPTS = new Set(["Avst", "Arab", "Armi", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]);
const RTL_LANGS = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);

/**
 * Determines if a locale is read right to left using [Intl.Locale]
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale}.
 */
function isRTL(locale) {
  // If the Intl.Locale API is available, use it to get the script for the locale.
  // This is more accurate than guessing by language, since languages can be written in multiple scripts.
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }

  // If not, just guess by the language (first part of the locale)
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
  return isRTL(locale) ? "rtl" : "ltr";
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useDefaultLocale.ts
 */
/**
 * Gets the locale setting of the browser.
 */
function getDefaultLocale() {
  let locale =
  // @ts-ignore
  typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([locale]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: getReadingDirection(locale)
  };
}
let currentLocale = getDefaultLocale();
const listeners = new Set();
function updateLocale() {
  currentLocale = getDefaultLocale();
  for (const listener of listeners) {
    listener(currentLocale);
  }
}

/**
 * Returns an accessor for the current browser/system language, and updates when it changes.
 */
function createDefaultLocale() {
  // We cannot determine the browser's language on the server, so default to en-US.
  // This will be updated after hydration on the client to the correct value.
  const defaultSSRLocale = {
    locale: "en-US",
    direction: "ltr"
  };
  const [defaultClientLocale, setDefaultClientLocale] = solidJs.createSignal(currentLocale);
  const defaultLocale = solidJs.createMemo(() => web.isServer ? defaultSSRLocale : defaultClientLocale());
  solidJs.onMount(() => {
    if (listeners.size === 0) {
      window.addEventListener("languagechange", updateLocale);
    }
    listeners.add(setDefaultClientLocale);
    solidJs.onCleanup(() => {
      listeners.delete(setDefaultClientLocale);
      if (listeners.size === 0) {
        window.removeEventListener("languagechange", updateLocale);
      }
    });
  });
  return {
    locale: () => defaultLocale().locale,
    direction: () => defaultLocale().direction
  };
}

const I18nContext = solidJs.createContext();

/**
 * Provides the locale for the application to all child components.
 */
function I18nProvider(props) {
  const defaultLocale = createDefaultLocale();
  const context = {
    locale: () => props.locale ?? defaultLocale.locale(),
    direction: () => props.locale ? getReadingDirection(props.locale) : defaultLocale.direction()
  };
  return web.createComponent(I18nContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

/**
 * Returns an accessor for the current locale and layout direction.
 */
function useLocale() {
  const defaultLocale = createDefaultLocale();
  const context = solidJs.useContext(I18nContext);
  return context || defaultLocale;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useCollator.ts
 */
const cache$1 = new Map();

/**
 * Provides localized string collation for the current locale. Automatically updates when the locale changes,
 * and handles caching of the collator for performance.
 * @param options - Collator options.
 */
function createCollator(options) {
  const {
    locale
  } = useLocale();
  const cacheKey = solidJs.createMemo(() => {
    return locale() + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  });
  return solidJs.createMemo(() => {
    const key = cacheKey();
    let collator;
    if (cache$1.has(key)) {
      collator = cache$1.get(key);
    }
    if (!collator) {
      collator = new Intl.Collator(locale(), options);
      cache$1.set(key, collator);
    }
    return collator;
  });
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/i18n/src/useDateFormatter.ts
 */
/**
 * Provides localized date formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the date formatter for performance.
 * @param options - Formatting options.
 */
function createDateFormatter(options) {
  const {
    locale
  } = useLocale();
  return solidJs.createMemo(() => new date.DateFormatter(locale(), utils.access(options)));
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/22cb32d329e66c60f55d4fc4025d1d44bb015d71/packages/@react-aria/i18n/src/useFilter.ts
 */
/**
 * Provides localized string search functionality that is useful for filtering or matching items
 * in a list. Options can be provided to adjust the sensitivity to case, diacritics, and other parameters.
 */
function createFilter(options) {
  const collator = createCollator({
    usage: "search",
    ...options
  });

  // TODO: these methods don't currently support the ignorePunctuation option.

  const startsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }

    // Normalize both strings so we can slice safely
    // TODO: take into account the ignorePunctuation option as well...
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    return collator().compare(str.slice(0, substr.length), substr) === 0;
  };
  const endsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    return collator().compare(str.slice(-substr.length), substr) === 0;
  };
  const contains = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    let scan = 0;
    const sliceLen = substr.length;
    for (; scan + sliceLen <= str.length; scan++) {
      const slice = str.slice(scan, scan + sliceLen);
      if (collator().compare(substr, slice) === 0) {
        return true;
      }
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/23c3a91e7b87952f07da9da115188bd2abd99d77/packages/@react-aria/i18n/src/useMessageFormatter.ts
 */
const cache = new WeakMap();
function getCachedDictionary(strings) {
  let dictionary = cache.get(strings);
  if (!dictionary) {
    dictionary = new message.MessageDictionary(strings);
    cache.set(strings, dictionary);
  }
  return dictionary;
}

/**
 * Handles formatting ICU Message strings to create localized strings for the current locale.
 * Automatically updates when the locale changes, and handles caching of messages for performance.
 * @param strings - A mapping of languages to strings by key.
 */
function createMessageFormatter(strings) {
  const {
    locale
  } = useLocale();
  const messageFormatter = solidJs.createMemo(() => {
    return new message.MessageFormatter(locale(), getCachedDictionary(utils.access(strings)));
  });

  // Re-export as a new object with narrowed type for the `format()` method.
  return solidJs.createMemo(() => ({
    format: (key, variables) => messageFormatter().format(key, variables)
  }));
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useNumberFormatter.ts
 */

/**
 * Provides localized number formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the number formatter for performance.
 * @param options - Formatting options.
 */
function createNumberFormatter(options) {
  const {
    locale
  } = useLocale();
  return solidJs.createMemo(() => new number.NumberFormatter(locale(), utils.access(options)));
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/Selection.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/types.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-types/shared/src/selection.d.ts
 */

/**
 * A Selection is a special Set containing Keys, which also has an anchor
 * and current selected key for use when range selecting.
 */
class Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
}

/**
 * Creates a simple reactive `Selection` state with a getter, setter and a fallback value of an empty selection,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSelectionSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Selection();
  return [value, setValue];
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/utils.ts
 */
function isNonContiguousSelectionModifier(e) {
  // Ctrl + Arrow Up/Arrow Down has a system-wide meaning on macOS, so use Alt instead.
  // On Windows and Ubuntu, Alt + Space has a system-wide meaning.
  return utils.isAppleDevice() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
  if (utils.isMac()) {
    return e.metaKey;
  }
  return e.ctrlKey;
}
function convertSelection(selection) {
  return new Selection(selection);
}
function isSameSelection(setA, setB) {
  if (setA.size !== setB.size) {
    return false;
  }
  for (const item of setA) {
    if (!setB.has(item)) {
      return false;
    }
  }
  return true;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/useMultipleSelectionState.ts
 */
/**
 * Manages state for multiple selection and focus in a collection.
 */
function createMultipleSelectionState(props) {
  props = utils.mergeDefaultProps({
    selectionMode: "none",
    selectionBehavior: "toggle"
  }, props);
  const [isFocused, setFocused] = solidJs.createSignal(false);
  const [focusedKey, setFocusedKey] = solidJs.createSignal();
  const selectedKeysProp = solidJs.createMemo(() => {
    const selection = utils.access(props.selectedKeys);
    if (!selection) {
      return;
    }
    return convertSelection(selection);
  });
  const defaultSelectedKeys = solidJs.createMemo(() => {
    const defaultSelection = utils.access(props.defaultSelectedKeys);
    if (!defaultSelection) {
      return new Selection();
    }
    return convertSelection(defaultSelection);
  });
  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
    value: selectedKeysProp,
    defaultValue: defaultSelectedKeys,
    onChange: value => props.onSelectionChange?.(value)
  });
  const [selectionBehavior, setSelectionBehavior] = solidJs.createSignal(utils.access(props.selectionBehavior));
  const selectionMode = () => utils.access(props.selectionMode);
  const disallowEmptySelection = () => utils.access(props.disallowEmptySelection) ?? false;
  const setSelectedKeys = keys => {
    if (utils.access(props.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {
      _setSelectedKeys(keys);
    }
  };

  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press
  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.
  solidJs.createEffect(() => {
    const selection = selectedKeys();
    if (utils.access(props.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) {
      setSelectionBehavior("replace");
    }
  });

  // If the selectionBehavior prop changes, update the state as well.
  solidJs.createEffect(() => {
    setSelectionBehavior(utils.access(props.selectionBehavior) ?? "toggle");
  });
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    isFocused,
    setFocused,
    focusedKey,
    setFocusedKey,
    selectedKeys,
    setSelectedKeys
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useTypeSelect.ts
 */
/**
 * Handles typeahead interactions with collections.
 */
function createTypeSelect(props) {
  const [search, setSearch] = solidJs.createSignal("");
  const [timeoutId, setTimeoutId] = solidJs.createSignal(-1);
  const onKeyDown = e => {
    if (utils.access(props.isDisabled)) {
      return;
    }
    const delegate = utils.access(props.keyboardDelegate);
    const manager = utils.access(props.selectionManager);
    if (!delegate.getKeyForSearch) {
      return;
    }
    const character = getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }

    // Do not propagate the Space bar event if it's meant to be part of the search.
    // When we time out, the search term becomes empty, hence the check on length.
    // Trimming is to account for the case of pressing the Space bar more than once,
    // which should cycle through the selection/deselection of the focused item.
    if (character === " " && search().trim().length > 0) {
      e.preventDefault();
      e.stopPropagation();
    }
    let newSearch = setSearch(prev => prev += character);

    // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.
    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);

    // If not key found, and the search is multiple iterations of the same letter (e.g "aaa"),
    // then cycle through first-letter matches
    if (key == null && isAllSameLetter(newSearch)) {
      newSearch = newSearch[0];
      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    }
    if (key != null) {
      manager.setFocusedKey(key);
      props.onTypeSelect?.(key);
    }
    clearTimeout(timeoutId());
    setTimeoutId(window.setTimeout(() => setSearch(""), 500));
  };
  return {
    typeSelectHandlers: {
      onKeyDown
    }
  };
}
function getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }
  return "";
}
function isAllSameLetter(search) {
  return search.split("").every(letter => letter === search[0]);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableCollection.ts
 */
/**
 * Handles interactions with selectable collections.
 * @param props Props for the collection.
 * @param ref The ref attached to the element representing the collection.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */
function createSelectableCollection(props, ref, scrollRef) {
  const defaultProps = {
    selectOnFocus: () => utils.access(props.selectionManager).selectionBehavior() === "replace"
  };
  props = solidJs.mergeProps(defaultProps, props);
  const finalScrollRef = () => scrollRef?.() ?? ref();
  const {
    direction
  } = useLocale();

  // Store the scroll position, so we can restore it later.
  let scrollPos = {
    top: 0,
    left: 0
  };
  utils.createEventListener(() => !utils.access(props.isVirtualized) ? finalScrollRef() : undefined, "scroll", () => {
    const scrollEl = finalScrollRef();
    if (!scrollEl) {
      return;
    }
    scrollPos = {
      top: scrollEl.scrollTop,
      left: scrollEl.scrollLeft
    };
  });
  const {
    typeSelectHandlers
  } = createTypeSelect({
    isDisabled: () => utils.access(props.disallowTypeAhead),
    keyboardDelegate: () => utils.access(props.keyboardDelegate),
    selectionManager: () => utils.access(props.selectionManager)
  });
  const onKeyDown = e => {
    utils.callHandler(e, typeSelectHandlers.onKeyDown);

    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
    if (e.altKey && e.key === "Tab") {
      e.preventDefault();
    }
    const refEl = ref();

    // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).
    if (!refEl?.contains(e.target)) {
      return;
    }
    const manager = utils.access(props.selectionManager);
    const selectOnFocus = utils.access(props.selectOnFocus);
    const navigateToKey = key => {
      if (key != null) {
        manager.setFocusedKey(key);
        if (e.shiftKey && manager.selectionMode() === "multiple") {
          manager.extendSelection(key);
        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };
    const delegate = utils.access(props.keyboardDelegate);
    const shouldFocusWrap = utils.access(props.shouldFocusWrap);
    const focusedKey = manager.focusedKey();
    switch (e.key) {
      case "ArrowDown":
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyBelow(focusedKey);
            } else {
              nextKey = delegate.getFirstKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowUp":
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyAbove(focusedKey);
            } else {
              nextKey = delegate.getLastKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowLeft":
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyLeftOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowRight":
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyRightOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
          if (firstKey != null) {
            manager.setFocusedKey(firstKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(firstKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(firstKey);
            }
          }
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
          if (lastKey != null) {
            manager.setFocusedKey(lastKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(lastKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(lastKey);
            }
          }
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageBelow(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageAbove(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && utils.access(props.disallowSelectAll) !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!e.defaultPrevented) {
          e.preventDefault();
          if (!utils.access(props.disallowEmptySelection)) {
            manager.clearSelection();
          }
        }
        break;
      case "Tab":
        {
          if (!utils.access(props.allowsTabNavigation)) {
            // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
            // However, collections should be treated as a single tab stop, with arrow key navigation internally.
            // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
            // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
            // in the collection, so that the browser default behavior will apply starting from that element
            // rather than the currently focused one.
            if (e.shiftKey) {
              refEl.focus();
            } else {
              const walker = utils.getFocusableTreeWalker(refEl, {
                tabbable: true
              });
              let next;
              let last;
              do {
                last = walker.lastChild();
                if (last) {
                  next = last;
                }
              } while (last);
              if (next && !next.contains(document.activeElement)) {
                utils.focusWithoutScrolling(next);
              }
            }
            break;
          }
        }
    }
  };
  const onFocusIn = e => {
    const manager = utils.access(props.selectionManager);
    const delegate = utils.access(props.keyboardDelegate);
    const selectOnFocus = utils.access(props.selectOnFocus);
    if (manager.isFocused()) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }
      return;
    }

    // Focus events can bubble through portals. Ignore these events.
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    manager.setFocused(true);
    if (manager.focusedKey() == null) {
      const navigateToFirstKey = key => {
        if (key == null) {
          return;
        }
        manager.setFocusedKey(key);
        if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      };

      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.
      const relatedTarget = e.relatedTarget;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
      } else {
        navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
      }
    } else if (!utils.access(props.isVirtualized)) {
      const scrollEl = finalScrollRef();
      if (scrollEl) {
        // Restore the scroll position to what it was before.
        scrollEl.scrollTop = scrollPos.top;
        scrollEl.scrollLeft = scrollPos.left;

        // Refocus and scroll the focused item into view if it exists within the scrollable region.
        const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
        if (element) {
          // This prevents a flash of focus on the first/last element in the collection
          utils.focusWithoutScrolling(element);
          utils.scrollIntoView(scrollEl, element);
        }
      }
    }
  };
  const onFocusOut = e => {
    const manager = utils.access(props.selectionManager);

    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };
  const onMouseDown = e => {
    // Ignore events that bubbled through portals.
    if (finalScrollRef() === e.target) {
      // Prevent focus going to the collection when clicking on the scrollbar.
      e.preventDefault();
    }
  };
  const tryAutoFocus = () => {
    const autoFocus = utils.access(props.autoFocus);
    if (!autoFocus) {
      return;
    }
    const manager = utils.access(props.selectionManager);
    const delegate = utils.access(props.keyboardDelegate);
    let focusedKey;

    // Check focus strategy to determine which item to focus
    if (autoFocus === "first") {
      focusedKey = delegate.getFirstKey?.();
    }
    if (autoFocus === "last") {
      focusedKey = delegate.getLastKey?.();
    }

    // If there are any selected keys, make the first one the new focus target
    const selectedKeys = manager.selectedKeys();
    if (selectedKeys.size) {
      focusedKey = selectedKeys.values().next().value;
    }
    manager.setFocused(true);
    manager.setFocusedKey(focusedKey);
    const refEl = ref();

    // If no default focus key is selected, focus the collection itself.
    if (refEl && focusedKey == null && !utils.access(props.shouldUseVirtualFocus)) {
      utils.focusWithoutScrolling(refEl);
    }
  };
  solidJs.onMount(() => {
    if (props.deferAutoFocus) {
      setTimeout(tryAutoFocus, 0); // TODO: does this work EVERY time ?
    } else {
      tryAutoFocus();
    }
  });

  // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, the Virtualizer should handle this.
  solidJs.createEffect(solidJs.on([finalScrollRef, () => utils.access(props.isVirtualized), () => utils.access(props.selectionManager).focusedKey()], newValue => {
    const [scrollEl, isVirtualized, focusedKey] = newValue;
    if (isVirtualized) {
      focusedKey && props.scrollToKey?.(focusedKey);
    } else {
      if (focusedKey && scrollEl) {
        const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
        if (element) {
          utils.scrollIntoView(scrollEl, element);
        }
      }
    }
  }));

  // If nothing is focused within the collection, make the collection itself tabbable.
  // This will be marshalled to either the first or last item depending on where focus came from.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
  // to move real DOM focus to the element anyway.
  const tabIndex = solidJs.createMemo(() => {
    if (utils.access(props.shouldUseVirtualFocus)) {
      return undefined;
    }
    return utils.access(props.selectionManager).focusedKey() == null ? 0 : -1;
  });
  return {
    tabIndex,
    onKeyDown,
    onMouseDown,
    onFocusIn,
    onFocusOut
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableItem.ts
 */
/**
 * Handles interactions with an item in a selectable collection.
 * @param props Props for the item.
 * @param ref Ref to the item.
 */
function createSelectableItem(props, ref) {
  const manager = () => utils.access(props.selectionManager);
  const key = () => utils.access(props.key);
  const shouldUseVirtualFocus = () => utils.access(props.shouldUseVirtualFocus);
  const onSelect = e => {
    if (manager().selectionMode() === "none") {
      return;
    }
    if (manager().selectionMode() === "single") {
      if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {
        manager().toggleSelection(key());
      } else {
        manager().replaceSelection(key());
      }
    } else if (e && e.shiftKey) {
      manager().extendSelection(key());
    } else if (manager().selectionBehavior() === "toggle" || isCtrlKeyPressed(e) || "pointerType" in e && e.pointerType === "touch") {
      // if touch then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
      manager().toggleSelection(key());
    } else {
      manager().replaceSelection(key());
    }
  };
  const isSelected = () => manager().isSelected(key());

  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.
  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.
  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.
  // With touch, onAction occurs on single tap, and long press enters selection mode.
  const isDisabled = () => utils.access(props.disabled) || manager().isDisabled(key());
  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());
  let pointerDownType = null;
  const onPointerDown = e => {
    if (!allowsSelection()) {
      return;
    }
    pointerDownType = e.pointerType;

    // Selection occurs on mouse down (main button).
    if (e.pointerType === "mouse" && e.button === 0 && !utils.access(props.shouldSelectOnPressUp)) {
      onSelect(e);
    }
  };

  // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPointerUp instead of onPointerDown.
  const onPointerUp = e => {
    if (!allowsSelection()) {
      return;
    }

    // If allowsDifferentPressOrigin, make selection happen on mouse up (main button).
    // Otherwise, have selection happen on click.
    if (e.pointerType === "mouse" && e.button === 0 && utils.access(props.shouldSelectOnPressUp) && utils.access(props.allowsDifferentPressOrigin)) {
      onSelect(e);
    }
  };
  const onClick = e => {
    if (!allowsSelection()) {
      return;
    }

    // If not allowsDifferentPressOrigin or pointerType is touch/pen, make selection happen on click.
    if (utils.access(props.shouldSelectOnPressUp) && !utils.access(props.allowsDifferentPressOrigin) || pointerDownType !== "mouse") {
      onSelect(e);
    }
  };

  // For keyboard events, selection occurs on key down (Enter or Space bar).
  const onKeyDown = e => {
    if (!allowsSelection() || !["Enter", " "].includes(e.key)) {
      return;
    }
    if (isNonContiguousSelectionModifier(e)) {
      manager().toggleSelection(key());
    } else {
      onSelect(e);
    }
  };
  const onMouseDown = e => {
    if (isDisabled()) {
      // Prevent focus going to the body when clicking on a disabled item.
      e.preventDefault();
    }
  };
  const onFocus = e => {
    const refEl = ref();
    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {
      return;
    }
    if (e.target === refEl) {
      manager().setFocusedKey(key());
    }
  };

  // Set tabIndex to 0 if the element is focused,
  // or -1 otherwise so that only the last focused item is tabbable.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver
  // on iOS 14 doesn't try to move real DOM focus to the item anyway.
  const tabIndex = solidJs.createMemo(() => {
    if (shouldUseVirtualFocus() || isDisabled()) {
      return undefined;
    }
    return key() === manager().focusedKey() ? 0 : -1;
  });

  // data-attribute used in selection manager and keyboard delegate
  const dataKey = solidJs.createMemo(() => {
    return utils.access(props.virtualized) ? undefined : key();
  });

  // Focus the associated DOM node when this item becomes the focusedKey.
  solidJs.createEffect(solidJs.on([ref, key, shouldUseVirtualFocus, () => manager().focusedKey(), () => manager().isFocused()], ([refEl, key, shouldUseVirtualFocus, focusedKey, isFocused]) => {
    if (refEl && key === focusedKey && isFocused && !shouldUseVirtualFocus && document.activeElement !== refEl) {
      if (props.focus) {
        props.focus();
      } else {
        utils.focusWithoutScrolling(refEl);
      }
    }
  }));
  return {
    isSelected,
    isDisabled,
    allowsSelection,
    tabIndex,
    dataKey,
    onPointerDown,
    onPointerUp,
    onClick,
    onKeyDown,
    onMouseDown,
    onFocus
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/SelectionManager.ts
 */

/**
 * An interface for reading and updating multiple selection state.
 */
class SelectionManager {
  constructor(collection, state) {
    this.collection = collection;
    this.state = state;
  }

  /** The type of selection that is allowed in the collection. */
  selectionMode() {
    return this.state.selectionMode();
  }

  /** Whether the collection allows empty selection. */
  disallowEmptySelection() {
    return this.state.disallowEmptySelection();
  }

  /** The selection behavior for the collection. */
  selectionBehavior() {
    return this.state.selectionBehavior();
  }

  /** Sets the selection behavior for the collection. */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }

  /** Whether the collection is currently focused. */
  isFocused() {
    return this.state.isFocused();
  }

  /** Sets whether the collection is focused. */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }

  /** The current focused key in the collection. */
  focusedKey() {
    return this.state.focusedKey();
  }

  /** Sets the focused key. */
  setFocusedKey(key) {
    if (key == null || this.collection().getItem(key)) {
      this.state.setFocusedKey(key);
    }
  }

  /** The currently selected keys in the collection. */
  selectedKeys() {
    return this.state.selectedKeys();
  }

  /** Returns whether a key is selected. */
  isSelected(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return false;
    }
    return this.state.selectedKeys().has(retrievedKey);
  }

  /** Whether the selection is empty. */
  isEmpty() {
    return this.state.selectedKeys().size === 0;
  }

  /** Whether all items in the collection are selected. */
  isSelectAll() {
    if (this.isEmpty()) {
      return false;
    }
    const selectedKeys = this.state.selectedKeys();
    return this.getAllSelectableKeys().every(k => selectedKeys.has(k));
  }
  firstSelectedKey() {
    let first;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
      if (!first || isItemBeforeFirst) {
        first = item;
      }
    }
    return first?.key;
  }
  lastSelectedKey() {
    let last;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
      if (!last || isItemAfterLast) {
        last = item;
      }
    }
    return last?.key;
  }

  /** Extends the selection to the given key. */
  extendSelection(toKey) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      this.replaceSelection(toKey);
      return;
    }
    const retrievedToKey = this.getKey(toKey);
    if (retrievedToKey == null) {
      return;
    }
    const selectedKeys = this.state.selectedKeys();
    const anchorKey = selectedKeys.anchorKey || retrievedToKey;
    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
    for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey)) {
      selection.delete(key);
    }
    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {
      if (this.canSelectItem(key)) {
        selection.add(key);
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    const fromItem = this.collection().getItem(from);
    const toItem = this.collection().getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    const keys = [];
    let key = from;
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item") {
        keys.push(key);
      }
      if (key === to) {
        return keys;
      }
      key = this.collection().getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    const item = this.collection().getItem(key);
    if (!item) {
      return key;
    }
    if (!item || item.type !== "item") {
      return null;
    }
    return item.key;
  }

  /** Toggles whether the given key is selected. */
  toggleSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const keys = new Selection(this.state.selectedKeys());
    if (keys.has(retrievedKey)) {
      keys.delete(retrievedKey);
    } else if (this.canSelectItem(retrievedKey)) {
      keys.add(retrievedKey);
      keys.anchorKey = retrievedKey;
      keys.currentKey = retrievedKey;
    }
    if (this.disallowEmptySelection() && keys.size === 0) {
      return;
    }
    this.state.setSelectedKeys(keys);
  }

  /** Replaces the selection with only the given key. */
  replaceSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();
    this.state.setSelectedKeys(selection);
  }

  /** Replaces the selection with the given keys. */
  setSelectedKeys(keys) {
    if (this.selectionMode() === "none") {
      return;
    }
    const selection = new Selection();
    for (const key of keys) {
      const retrievedKey = this.getKey(key);
      if (retrievedKey != null) {
        selection.add(retrievedKey);
        if (this.selectionMode() === "single") {
          break;
        }
      }
    }
    this.state.setSelectedKeys(selection);
  }

  /** Selects all items in the collection. */
  selectAll() {
    if (this.selectionMode() === "multiple") {
      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
  }

  /**
   * Removes all keys from the selection.
   */
  clearSelection() {
    const selectedKeys = this.state.selectedKeys();
    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {
      this.state.setSelectedKeys(new Selection());
    }
  }

  /**
   * Toggles between select all and an empty selection.
   */
  toggleSelectAll() {
    if (this.isSelectAll()) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }
  select(key, e) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection()) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (this.selectionBehavior() === "toggle" || e && e.pointerType === "touch") {
      // if touch then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
      this.toggleSelection(key);
    } else {
      this.replaceSelection(key);
    }
  }

  /** Returns whether the current selection is equal to the given selection. */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys()) {
      return true;
    }

    // Check if the set of keys match.
    const selectedKeys = this.selectedKeys();
    if (selection.size !== selectedKeys.size) {
      return false;
    }
    for (const key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }
    for (const key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const item = this.collection().getItem(key);
    return item != null && !item.disabled;
  }
  isDisabled(key) {
    const item = this.collection().getItem(key);
    return !item || item.disabled;
  }
  getAllSelectableKeys() {
    const keys = [];
    const addKeys = key => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          const item = this.collection().getItem(key);
          if (!item) {
            continue;
          }
          if (item.type === "item") {
            keys.push(key);
          }
        }
        key = this.collection().getKeyAfter(key);
      }
    };
    addKeys(this.collection().getFirstKey());
    return keys;
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/ListCollection.ts
 */

class ListCollection {
  keyMap = new Map();
  constructor(nodes) {
    this.iterable = nodes;
    for (const node of nodes) {
      this.keyMap.set(node.key, node);
    }
    if (this.keyMap.size === 0) {
      return;
    }
    let last;
    let index = 0;
    for (const [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }
      if (node.type === "item") {
        node.index = index++;
      }
      last = node;

      // Set nextKey as undefined since this might be the last node
      // If it isn't the last node, last.nextKey will properly set at start of new loop
      last.nextKey = undefined;
    }
    this.lastKey = last.key;
  }
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  getSize() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    return this.keyMap.get(key)?.prevKey;
  }
  getKeyAfter(key) {
    return this.keyMap.get(key)?.nextKey;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/useListState.ts
 */
/**
 * Provides state management for list-like components.
 * Handles building a collection of items from props, and manages multiple selection state.
 */
function createListState(props) {
  const selectionState = createMultipleSelectionState(props);
  const factory = nodes => {
    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
  };
  const collection = createCollection({
    dataSource: () => utils.access(props.dataSource),
    getKey: () => utils.access(props.getKey),
    getTextValue: () => utils.access(props.getTextValue),
    getDisabled: () => utils.access(props.getDisabled),
    getSectionChildren: () => utils.access(props.getSectionChildren),
    factory
  }, [() => props.filter]);
  const selectionManager = new SelectionManager(collection, selectionState);

  // Reset focused key if that item is deleted from the collection.
  solidJs.createComputed(() => {
    const focusedKey = selectionState.focusedKey();
    if (focusedKey != null && !collection().getItem(focusedKey)) {
      selectionState.setFocusedKey(undefined);
    }
  });
  return {
    collection,
    selectionManager: () => selectionManager
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/ListKeyboardDelegate.ts
 */

class ListKeyboardDelegate {
  constructor(collection, ref, collator) {
    this.collection = collection;
    this.ref = ref;
    this.collator = collator;
  }
  getKeyBelow(key) {
    let keyAfter = this.collection().getKeyAfter(key);
    while (keyAfter != null) {
      const item = this.collection().getItem(keyAfter);
      if (item && item.type === "item" && !item.disabled) {
        return keyAfter;
      }
      keyAfter = this.collection().getKeyAfter(keyAfter);
    }
  }
  getKeyAbove(key) {
    let keyBefore = this.collection().getKeyBefore(key);
    while (keyBefore != null) {
      const item = this.collection().getItem(keyBefore);
      if (item && item.type === "item" && !item.disabled) {
        return keyBefore;
      }
      keyBefore = this.collection().getKeyBefore(keyBefore);
    }
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyAfter(key);
    }
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyBefore(key);
    }
  }
  getItem(key) {
    return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
  }

  // TODO: not working correctly
  getKeyPageAbove(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
    let keyAbove = key;
    while (keyAbove && item && item.offsetTop > pageY) {
      keyAbove = this.getKeyAbove(keyAbove);
      item = keyAbove != null ? this.getItem(keyAbove) : null;
    }
    return keyAbove;
  }

  // TODO: not working correctly
  getKeyPageBelow(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
    let keyBelow = key;
    while (keyBelow && item && item.offsetTop < pageY) {
      keyBelow = this.getKeyBelow(keyBelow);
      item = keyBelow != null ? this.getItem(keyBelow) : null;
    }
    return keyBelow;
  }
  getKeyForSearch(search, fromKey) {
    const collator = this.collator?.();
    if (!collator) {
      return;
    }

    // Prevent from getting the same key twice
    let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        const substring = item.textValue.slice(0, search.length);
        if (item.textValue && collator.compare(substring, search) === 0) {
          return key;
        }
      }
      key = this.getKeyBelow(key);
    }
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableList.ts
 */
/**
 * Handles interactions with a selectable list.
 * @param props Props for the list.
 * @param ref A ref to the list element.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */
function createSelectableList(props, ref, scrollRef) {
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });

  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(props.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(props.collection, ref, collator);
  });
  return createSelectableCollection({
    selectionManager: () => utils.access(props.selectionManager),
    keyboardDelegate: delegate,
    autoFocus: () => utils.access(props.autoFocus),
    deferAutoFocus: () => utils.access(props.deferAutoFocus),
    shouldFocusWrap: () => utils.access(props.shouldFocusWrap),
    disallowEmptySelection: () => utils.access(props.disallowEmptySelection),
    selectOnFocus: () => utils.access(props.selectOnFocus),
    disallowTypeAhead: () => utils.access(props.disallowTypeAhead),
    shouldUseVirtualFocus: () => utils.access(props.shouldUseVirtualFocus),
    allowsTabNavigation: () => utils.access(props.allowsTabNavigation),
    isVirtualized: () => utils.access(props.isVirtualized),
    scrollToKey: key => utils.access(props.scrollToKey)?.(key)
  }, ref, scrollRef);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-stately/list/src/useSingleSelectListState.ts
 */
/**
 * Provides state management for list-like components with single selection.
 * Handles building a collection of items from props, and manages selection state.
 */
function createSingleSelectListState(props) {
  const [selectedKey, setSelectedKey] = createControllableSignal({
    value: () => utils.access(props.selectedKey),
    defaultValue: () => utils.access(props.defaultSelectedKey),
    onChange: value => props.onSelectionChange?.(value)
  });
  const selectedKeys = solidJs.createMemo(() => {
    const selection = selectedKey();
    return selection != null ? [selection] : [];
  });
  const [, defaultCreateListStateProps] = solidJs.splitProps(props, ["onSelectionChange"]);
  const createListStateProps = solidJs.mergeProps(defaultCreateListStateProps, {
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: keys => {
      const key = keys.values().next().value;

      // Always fire onSelectionChange, even if the key is the same
      // as the current key (createControllableSignal does not).
      if (key === selectedKey()) {
        props.onSelectionChange?.(key);
      }
      setSelectedKey(key);
    }
  });
  const {
    collection,
    selectionManager
  } = createListState(createListStateProps);
  const selectedItem = solidJs.createMemo(() => {
    const selection = selectedKey();
    return selection != null ? collection().getItem(selection) : undefined;
  });
  return {
    collection,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

const [state, setState] = store.createStore({
  toasts: []
});
function add(toast) {
  setState("toasts", prev => [...prev, toast]);
}
function get(id) {
  return state.toasts.find(toast => toast.id === id);
}
function update$1(id, toast) {
  const index = state.toasts.findIndex(toast => toast.id === id);
  if (index != -1) {
    setState("toasts", prev => [...prev.slice(0, index), toast, ...prev.slice(index + 1)]);
  }
}
function dismiss$1(id) {
  setState("toasts", toast => toast.id === id, "dismiss", true);
}
function remove(id) {
  setState("toasts", prev => prev.filter(toast => toast.id !== id));
}
function clear$1() {
  setState("toasts", []);
}
const toastStore = {
  toasts: () => state.toasts,
  add,
  get,
  update: update$1,
  dismiss: dismiss$1,
  remove,
  clear: clear$1
};

let toastsCounter = 0;

/** Adds a new toast to the visible toasts or queue depending on current state and limit, and return the id of the created toast. */
function show(toastComponent, options) {
  const id = toastsCounter++;
  toastStore.add({
    id,
    toastComponent,
    dismiss: false,
    update: false,
    region: options?.region
  });
  return id;
}

/** Update the toast of the given id with a new rendered component. */
function update(id, toastComponent) {
  toastStore.update(id, {
    id,
    toastComponent,
    dismiss: false,
    update: true
  });
}

/** Adds a new promise-based toast to the visible toasts or queue depending on current state and limit, and return the id of the created toast. */
function promise(promise, toastComponent, options) {
  const id = show(props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "pending"
    });
  }, options);
  (utils.isFunction(promise) ? promise() : promise).then(data => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "fulfilled",
      data
    });
  })).catch(error => update(id, props => {
    return toastComponent({
      get toastId() {
        return props.toastId;
      },
      state: "rejected",
      error
    });
  }));
  return id;
}

/** Removes toast with given id from visible toasts and queue. */
function dismiss(id) {
  toastStore.dismiss(id);
  return id;
}

/** Removes all toasts from visible toasts and queue. */
function clear() {
  toastStore.clear();
}

// User facing API.
const toaster = {
  show,
  update,
  promise,
  dismiss,
  clear
};

const CollapsibleContext = solidJs.createContext();
function useCollapsibleContext() {
  const context = solidJs.useContext(CollapsibleContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCollapsibleContext` must be used within a `Collapsible.Root` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the collapsible is expanded.
 */
function CollapsibleContent(props) {
  let ref;
  const context = useCollapsibleContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style"]);
  const presence = createPresence(() => context.shouldMount());
  const [height, setHeight] = solidJs.createSignal(0);
  const [width, setWidth] = solidJs.createSignal(0);

  // When opening we want it to immediately open to retrieve dimensions.
  // When closing we delay `isPresent` to retrieve dimensions before closing.
  const isOpen = () => context.isOpen() || presence.isPresent();
  let isMountAnimationPrevented = isOpen();
  let originalStyles;
  solidJs.onMount(() => {
    const raf = requestAnimationFrame(() => {
      isMountAnimationPrevented = false;
    });
    solidJs.onCleanup(() => {
      cancelAnimationFrame(raf);
    });
  });
  solidJs.createEffect(solidJs.on(
  /**
   * depends on `presence.isPresent` because it will be `false` on
   * animation end (so when close finishes). This allows us to
   * retrieve the dimensions *before* closing.
   */
  [() => presence.isPresent()], () => {
    if (!ref) {
      return;
    }
    originalStyles = originalStyles || {
      transitionDuration: ref.style.transitionDuration,
      animationName: ref.style.animationName
    };

    // block any animations/transitions so the element renders at its full dimensions
    ref.style.transitionDuration = "0s";
    ref.style.animationName = "none";

    // get width and height from full dimensions
    const rect = ref.getBoundingClientRect();
    setHeight(rect.height);
    setWidth(rect.width);

    // kick off any animations/transitions that were originally set up if it isn't the initial mount
    if (!isMountAnimationPrevented) {
      ref.style.transitionDuration = originalStyles.transitionDuration;
      ref.style.animationName = originalStyles.animationName;
    }
  }));
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(local.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return local.id;
        },
        get style() {
          return {
            "--kb-collapsible-content-height": height() ? `${height()}px` : undefined,
            "--kb-collapsible-content-width": width() ? `${width()}px` : undefined,
            ...local.style
          };
        }
      }, () => context.dataset(), others));
    }
  });
}

/**
 * An interactive component which expands/collapses a content.
 */
function CollapsibleRoot(props) {
  const defaultId = `collapsible-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["open", "defaultOpen", "onOpenChange", "disabled", "forceMount"]);
  const [contentId, setContentId] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    disabled: () => local.disabled ?? false,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    contentId,
    toggle: disclosureState.toggle,
    generateId: utils.createGenerateId(() => others.id),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(CollapsibleContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, dataset, others));
    }
  });
}

/*!
 * Portions of this file are based on code from ariakit
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/hope-ui/hope-ui/blob/54125b130195f37161dbeeea0c21dc3b198bc3ac/packages/core/src/button/is-button.ts
 */

const BUTTON_INPUT_TYPES = ["button", "color", "file", "image", "reset", "submit"];

/**
 * Checks whether `element` is a native HTML button element.
 * @example
 * isButton(document.querySelector("button")); // true
 * isButton(document.querySelector("input[type='button']")); // true
 * isButton(document.querySelector("div")); // false
 * isButton(document.querySelector("input[type='text']")); // false
 * isButton(document.querySelector("div[role='button']")); // false
 */
function isButton(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "button") {
    return true;
  }
  if (tagName === "input" && element.type) {
    return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
  }
  return false;
}

/**
 * Button enables users to trigger an action or event, such as submitting a form,
 * opening a dialog, canceling an action, or performing a delete operation.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */
function ButtonRoot(props) {
  let ref;
  props = utils.mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "type", "disabled"]);
  const tagName = createTagName(() => ref, () => "button");
  const isNativeButton = solidJs.createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: local.type
    });
  });
  const isNativeInput = solidJs.createMemo(() => {
    return tagName() === "input";
  });
  const isNativeLink = solidJs.createMemo(() => {
    return tagName() === "a" && ref?.getAttribute("href") != null;
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get type() {
      return isNativeButton() || isNativeInput() ? local.type : undefined;
    },
    get role() {
      return !isNativeButton() && !isNativeLink() ? "button" : undefined;
    },
    get tabIndex() {
      return !isNativeButton() && !isNativeLink() && !local.disabled ? 0 : undefined;
    },
    get disabled() {
      return isNativeButton() || isNativeInput() ? local.disabled : undefined;
    },
    get ["aria-disabled"]() {
      return !isNativeButton() && !isNativeInput() && local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$p = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: ButtonRoot
});

/**
 * The button that expands/collapses the collapsible content.
 */
function CollapsibleTrigger(props) {
  const context = useCollapsibleContext();
  const [local, others] = solidJs.splitProps(props, ["onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get disabled() {
      return context.disabled();
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$o = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: CollapsibleContent,
  Root: CollapsibleRoot,
  Trigger: CollapsibleTrigger
});

const AccordionItemContext = solidJs.createContext();
function useAccordionItemContext() {
  const context = solidJs.useContext(AccordionItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionItemContext` must be used within a `Accordion.Item` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the `Accordion.Item` is expanded.
 */
function AccordionContent(props) {
  const itemContext = useAccordionItemContext();
  const defaultId = itemContext.generateId("content");
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["style"]);
  solidJs.createEffect(() => solidJs.onCleanup(itemContext.registerContentId(others.id)));
  return web.createComponent(CollapsibleContent, web.mergeProps({
    role: "region",
    get ["aria-labelledby"]() {
      return itemContext.triggerId();
    },
    get style() {
      return {
        "--kb-accordion-content-height": "var(--kb-collapsible-content-height)",
        "--kb-accordion-content-width": "var(--kb-collapsible-content-width)",
        ...local.style
      };
    }
  }, others));
}

/**
 * Wraps an `Accordion.Trigger`.
 * Use the `as` prop to update it to the appropriate heading level for your page.
 */
function AccordionHeader(props) {
  // `Accordion.Item` is a `Collapsible.Root`.
  const context = useCollapsibleContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h3"
  }, () => context.dataset(), props));
}

const AccordionContext = solidJs.createContext();
function useAccordionContext() {
  const context = solidJs.useContext(AccordionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionContext` must be used within a `Accordion.Root` component");
  }
  return context;
}

/**
 * An item of the accordion, contains all the parts of a collapsible section.
 */
function AccordionItem(props) {
  const accordionContext = useAccordionContext();
  const defaultId = `${accordionContext.generateId("item")}-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "disabled"]);
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const selectionManager = () => accordionContext.listState().selectionManager();
  const isExpanded = () => {
    return selectionManager().isSelected(local.value);
  };
  const context = {
    value: () => local.value,
    triggerId,
    contentId,
    generateId: utils.createGenerateId(() => others.id),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(AccordionItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(CollapsibleRoot, web.mergeProps({
        get open() {
          return isExpanded();
        },
        get disabled() {
          return local.disabled;
        }
      }, others));
    }
  });
}

const DomCollectionContext = solidJs.createContext();
function useOptionalDomCollectionContext() {
  return solidJs.useContext(DomCollectionContext);
}
function useDomCollectionContext() {
  const context = useOptionalDomCollectionContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
  }
  return context;
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 */
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  const itemEl = item.ref();
  if (!itemEl) {
    return -1;
  }
  let length = items.length;
  if (!length) {
    return -1;
  }

  // Most of the time, the new item will be added at the end of the list, so we
  // do a findIndex in reverse order, instead of wasting time searching the
  // index from the beginning.
  while (length--) {
    const currentItemEl = items[length]?.ref();
    if (!currentItemEl) {
      continue;
    }
    if (isElementPreceding(currentItemEl, itemEl)) {
      return length + 1;
    }
  }
  return 0;
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.ref();
    const elementB = b.ref();
    if (elementA === elementB) {
      return 0;
    }
    if (!elementA || !elementB) {
      return 0;
    }

    // a before b
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }

    // a after b
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  const sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  const firstItem = items[0];
  const lastItemEl = items[items.length - 1]?.ref();
  let parentEl = firstItem?.ref()?.parentElement;
  while (parentEl) {
    if (lastItemEl && parentEl.contains(lastItemEl)) {
      return parentEl;
    }
    parentEl = parentEl.parentElement;
  }
  return utils.getDocument(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
  solidJs.createEffect(() => {
    const timeout = setTimeout(() => {
      setItemsBasedOnDOMPosition(items(), setItems);
    });
    solidJs.onCleanup(() => clearTimeout(timeout));
  });
}
function createSortBasedOnDOMPosition(items, setItems) {
  // JSDOM doesn't support IntersectionObserver. See https://github.com/jsdom/jsdom/issues/2032
  if (typeof IntersectionObserver !== "function") {
    createTimeoutObserver(items, setItems);
    return;
  }
  let previousItems = [];
  solidJs.createEffect(() => {
    const callback = () => {
      const hasPreviousItems = !!previousItems.length;
      previousItems = items();

      // We don't want to sort items if items have been just registered.
      if (!hasPreviousItems) {
        return;
      }
      setItemsBasedOnDOMPosition(items(), setItems);
    };
    const root = getCommonParent(items());
    const observer = new IntersectionObserver(callback, {
      root
    });
    items().forEach(item => {
      const itemEl = item.ref();
      if (itemEl) {
        observer.observe(itemEl);
      }
    });
    solidJs.onCleanup(() => observer.disconnect());
  });
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection.tsx
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-item.ts
 */
function createDomCollection(props = {}) {
  const [items, setItems] = createControllableArraySignal({
    value: () => utils.access(props.items),
    onChange: value => props.onItemsChange?.(value)
  });
  createSortBasedOnDOMPosition(items, setItems);
  const registerItem = item => {
    setItems(prevItems => {
      // Finds the item group based on the DOM hierarchy
      const index = findDOMIndex(prevItems, item);
      return utils.addItemToArray(prevItems, item, index);
    });
    return () => {
      setItems(prevItems => {
        const nextItems = prevItems.filter(prevItem => prevItem.ref() !== item.ref());
        if (prevItems.length === nextItems.length) {
          // The item isn't registered, so do nothing
          return prevItems;
        }
        return nextItems;
      });
    };
  };
  const DomCollectionProvider = props => {
    return solidJs.createComponent(DomCollectionContext.Provider, {
      value: {
        registerItem
      },
      get children() {
        return props.children;
      }
    });
  };
  return {
    DomCollectionProvider
  };
}

function createDomCollectionItem(props) {
  const context = useDomCollectionContext();
  props = utils.mergeDefaultProps({
    shouldRegisterItem: true
  }, props);
  solidJs.createEffect(() => {
    if (!props.shouldRegisterItem) {
      return;
    }
    const unregister = context.registerItem(props.getItem());
    solidJs.onCleanup(unregister);
  });
}

/**
 * A vertically stacked set of interactive headings that each reveal an associated section of content.
 */
function AccordionRoot(props) {
  let ref;
  const defaultId = `accordion-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    multiple: false,
    collapsible: false,
    shouldFocusWrap: true
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "value", "defaultValue", "onChange", "multiple", "collapsible", "shouldFocusWrap", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const [items, setItems] = solidJs.createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createListState({
    selectedKeys: () => local.value,
    defaultSelectedKeys: () => local.defaultValue,
    onSelectionChange: value => local.onChange?.(Array.from(value)),
    disallowEmptySelection: () => !local.multiple && !local.collapsible,
    selectionMode: () => local.multiple ? "multiple" : "single",
    dataSource: items
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState.selectionManager(),
    collection: () => listState.collection(),
    disallowEmptySelection: () => listState.selectionManager().disallowEmptySelection(),
    shouldFocusWrap: () => local.shouldFocusWrap,
    disallowTypeAhead: true,
    allowsTabNavigation: true
  }, () => ref);
  const context = {
    listState: () => listState,
    generateId: utils.createGenerateId(() => others.id)
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(AccordionContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get onKeyDown() {
              return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
            },
            get onMouseDown() {
              return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
}

/**
 * Toggles the collapsed state of its associated item. It should be nested inside an `Accordion.Header`.
 */
function AccordionTrigger(props) {
  let ref;
  const accordionContext = useAccordionContext();
  const itemContext = useAccordionItemContext();
  const collapsibleContext = useCollapsibleContext();
  const defaultId = itemContext.generateId("trigger");
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: itemContext.value(),
      textValue: "",
      // not applicable here
      disabled: collapsibleContext.disabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => itemContext.value(),
    selectionManager: () => accordionContext.listState().selectionManager(),
    disabled: () => collapsibleContext.disabled(),
    shouldSelectOnPressUp: true
  }, () => ref);
  const onKeyDown = e => {
    // Prevent `Enter` and `Space` default behavior which fires a click event when using a <button>.
    if (["Enter", " "].includes(e.key)) {
      e.preventDefault();
    }
    utils.callHandler(e, local.onKeyDown);
    utils.callHandler(e, selectableItem.onKeyDown);
  };
  solidJs.createEffect(() => solidJs.onCleanup(itemContext.registerTriggerId(others.id)));
  return web.createComponent(CollapsibleTrigger, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
    },
    onKeyDown: onKeyDown,
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$n = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: AccordionContent,
  Header: AccordionHeader,
  Item: AccordionItem,
  Root: AccordionRoot,
  Trigger: AccordionTrigger
});

/**
 * Alert displays a brief, important message
 * in a way that attracts the user's attention without interrupting the user's task.
 */
function AlertRoot(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "alert"
  }, props));
}

var index$m = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: AlertRoot
});

const DialogContext = solidJs.createContext();
function useDialogContext() {
  const context = solidJs.useContext(DialogContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDialogContext` must be used within a `Dialog` component");
  }
  return context;
}

/**
 * The button that closes the dialog.
 */
function DialogCloseButton(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const messageFormatter = createMessageFormatter(() => COMMON_INTL_MESSAGES);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || messageFormatter().format("dismiss");
    },
    onClick: onClick
  }, others));
}

const DismissableLayerContext = solidJs.createContext();
function useOptionalDismissableLayerContext() {
  return solidJs.useContext(DismissableLayerContext);
}

function DismissableLayer(props) {
  let ref;
  const parentContext = useOptionalDismissableLayerContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "disableOutsidePointerEvents", "excludedElements", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "bypassTopMostLayerCheck"]);
  const nestedLayers = new Set([]);
  const registerNestedLayer = element => {
    nestedLayers.add(element);
    const parentUnregister = parentContext?.registerNestedLayer(element);
    return () => {
      nestedLayers.delete(element);
      parentUnregister?.();
    };
  };
  const shouldExcludeElement = element => {
    if (!ref) {
      return false;
    }
    return local.excludedElements?.some(node => utils.contains(node(), element)) || [...nestedLayers].some(layer => utils.contains(layer, element));
  };
  const onPointerDownOutside = e => {
    if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) {
      return;
    }
    if (!local.bypassTopMostLayerCheck && !layerStack.isTopMostLayer(ref)) {
      return;
    }
    local.onPointerDownOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  createInteractOutside({
    shouldExcludeElement,
    onPointerDownOutside,
    onFocusOutside
  }, () => ref);
  createEscapeKeyDown({
    ownerDocument: () => utils.getDocument(ref),
    onEscapeKeyDown: e => {
      if (!ref || !layerStack.isTopMostLayer(ref)) {
        return;
      }
      local.onEscapeKeyDown?.(e);
      if (!e.defaultPrevented && local.onDismiss) {
        e.preventDefault();
        local.onDismiss();
      }
    }
  });
  solidJs.onMount(() => {
    if (!ref) {
      return;
    }
    layerStack.addLayer({
      node: ref,
      isPointerBlocking: local.disableOutsidePointerEvents,
      dismiss: local.onDismiss
    });
    const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
    layerStack.assignPointerEventToLayers();
    layerStack.disableBodyPointerEvents(ref);
    solidJs.onCleanup(() => {
      if (!ref) {
        return;
      }
      layerStack.removeLayer(ref);
      unregisterFromParentLayer?.();

      // Re-assign pointer event to remaining layers.
      layerStack.assignPointerEventToLayers();
      layerStack.restoreBodyPointerEvents(ref);
    });
  });
  solidJs.createEffect(solidJs.on([() => ref, () => local.disableOutsidePointerEvents], ([ref, disableOutsidePointerEvents]) => {
    if (!ref) {
      return;
    }
    const layer = layerStack.find(ref);
    if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
      // Keep layer in sync with the prop.
      layer.isPointerBlocking = disableOutsidePointerEvents;

      // Update layers pointer-events since this layer "isPointerBlocking" has changed.
      layerStack.assignPointerEventToLayers();
    }
    if (disableOutsidePointerEvents) {
      layerStack.disableBodyPointerEvents(ref);
    }
    solidJs.onCleanup(() => {
      layerStack.restoreBodyPointerEvents(ref);
    });
  }, {
    defer: true
  }));
  const context = {
    registerNestedLayer
  };
  return web.createComponent(DismissableLayerContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others));
    }
  });
}

/**
 * Contains the content to be rendered when the dialog is open.
 */
function DialogContent(props) {
  let ref;
  const context = useDialogContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);

    // If the event is a right-click, we shouldn't close because
    // it is effectively as if we right-clicked the `Overlay`.
    if (context.modal() && e.detail.isContextMenu) {
      e.preventDefault();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.modal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.modal()) {
      return;
    }

    // Non-modal behavior below

    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }

    // Prevent dismissing when clicking the trigger.
    // As the trigger is already setup to close, without doing so would
    // cause it to close and immediately open.
    if (utils.contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }

    // On Safari if the trigger is inside a container with tabIndex={0}, when clicked
    // we will get the pointer down outside event on the trigger, but then a subsequent
    // focus outside event on the container, we ignore any focus outside event when we've
    // already had a pointer down outside event.
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.modal()) {
      e.preventDefault();
      utils.focusWithoutScrolling(context.triggerRef());
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          utils.focusWithoutScrolling(context.triggerRef());
        }

        // Always prevent autofocus because we either focus manually or want user agent focus
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.modal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    ownerRef: () => ref,
    isDisabled: () => !(context.isOpen() && (context.modal() || context.preventScroll()))
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.modal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(DismissableLayer, web.mergeProps({
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            context.contentPresence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "dialog",
        tabIndex: -1,
        get disableOutsidePointerEvents() {
          return web.memo(() => !!context.modal())() && context.isOpen();
        },
        get excludedElements() {
          return [context.triggerRef];
        },
        get ["aria-labelledby"]() {
          return context.titleId();
        },
        get ["aria-describedby"]() {
          return context.descriptionId();
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: onFocusOutside,
        onInteractOutside: onInteractOutside,
        get onDismiss() {
          return context.close;
        }
      }, others));
    }
  });
}

/**
 * An optional accessible description to be announced when the dialog is open.
 */
function DialogDescription(props) {
  const context = useDialogContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "p",
    get id() {
      return local.id;
    }
  }, others));
}

/**
 * A layer that covers the inert portion of the view when the dialog is open.
 */
function DialogOverlay(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "onPointerDown"]);
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);

    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.overlayPresence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(context.overlayPresence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get style() {
          return {
            "pointer-events": "auto",
            ...local.style
          };
        },
        get ["data-expanded"]() {
          return context.isOpen() ? "" : undefined;
        },
        get ["data-closed"]() {
          return !context.isOpen() ? "" : undefined;
        },
        onPointerDown: onPointerDown
      }, others));
    }
  });
}

/**
 * Portals its children into the `body` when the dialog is open.
 */
function DialogPortal(props) {
  const context = useDialogContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent() || context.overlayPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/**
 * A dialog is a window overlaid on either the primary window or another dialog window.
 */
function DialogRoot(props) {
  const defaultId = `dialog-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    modal: true,
    preventScroll: false
  }, props);
  const [contentId, setContentId] = solidJs.createSignal();
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => props.open,
    defaultOpen: () => props.defaultOpen,
    onOpenChange: isOpen => props.onOpenChange?.(isOpen)
  });
  const shouldMount = () => props.forceMount || disclosureState.isOpen();
  const overlayPresence = createPresence(shouldMount);
  const contentPresence = createPresence(shouldMount);
  const context = {
    isOpen: disclosureState.isOpen,
    modal: () => props.modal ?? true,
    preventScroll: () => props.preventScroll ?? false,
    contentId,
    titleId,
    descriptionId,
    triggerRef,
    overlayPresence,
    contentPresence,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    setTriggerRef,
    generateId: utils.createGenerateId(() => props.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(DialogContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

/**
 * An accessible title to be announced when the dialog is open.
 */
function DialogTitle(props) {
  const context = useDialogContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h2",
    get id() {
      return local.id;
    }
  }, others));
}

/**
 * The button that opens the dialog.
 */
function DialogTrigger(props) {
  const context = useDialogContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    get ["data-closed"]() {
      return !context.isOpen() ? "" : undefined;
    },
    onClick: onClick
  }, others));
}

var index$l = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CloseButton: DialogCloseButton,
  Content: DialogContent,
  Description: DialogDescription,
  Overlay: DialogOverlay,
  Portal: DialogPortal,
  Root: DialogRoot,
  Title: DialogTitle,
  Trigger: DialogTrigger
});

/**
 * Overrides the regular `Dialog.Content` with role="alertdialog" to interrupt the user.
 */
function AlertDialogContent(props) {
  return web.createComponent(DialogContent, web.mergeProps({
    role: "alertdialog"
  }, props));
}

var index$k = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CloseButton: DialogCloseButton,
  Content: AlertDialogContent,
  Description: DialogDescription,
  Overlay: DialogOverlay,
  Portal: DialogPortal,
  Root: DialogRoot,
  Title: DialogTitle,
  Trigger: DialogTrigger
});

/**
 * Link allows a user to navigate to another page or resource within a web page or application.
 */
function LinkRoot(props) {
  let ref;
  const [local, others] = solidJs.splitProps(props, ["ref", "type", "href", "disabled"]);
  const tagName = createTagName(() => ref, () => "a");
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "a",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "a" || local.disabled ? "link" : undefined;
    },
    get tabIndex() {
      return tagName() !== "a" && !local.disabled ? 0 : undefined;
    },
    get href() {
      return !local.disabled ? local.href : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    }
  }, others));
}

var index$j = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: LinkRoot
});

/**
 * The breadcrumbs link.
 */
function BreadcrumbsLink(props) {
  const [local, others] = solidJs.splitProps(props, ["current", "disabled", "aria-current"]);
  const ariaCurrent = () => {
    if (!local.current) {
      return undefined;
    }
    return local["aria-current"] || "page";
  };
  return web.createComponent(LinkRoot, web.mergeProps({
    get disabled() {
      return local.disabled || local.current;
    },
    get ["aria-current"]() {
      return ariaCurrent();
    },
    get ["data-current"]() {
      return local.current ? "" : undefined;
    }
  }, others));
}

const BREADCRUMBS_INTL_MESSAGES = {
  "ar-AE": {
    breadcrumbs: " "
  },
  "bg-BG": {
    breadcrumbs: " "
  },
  "cs-CZ": {
    breadcrumbs: "Popis cesty"
  },
  "da-DK": {
    breadcrumbs: "Brdkrummer"
  },
  "de-DE": {
    breadcrumbs: "Breadcrumbs"
  },
  "el-GR": {
    breadcrumbs: " breadcrumb"
  },
  "en-US": {
    breadcrumbs: "Breadcrumbs"
  },
  "es-ES": {
    breadcrumbs: "Migas de pan"
  },
  "et-EE": {
    breadcrumbs: "Lingiread"
  },
  "fi-FI": {
    breadcrumbs: "Navigointilinkit"
  },
  "fr-FR": {
    breadcrumbs: "Chemin de navigation"
  },
  "he-IL": {
    breadcrumbs: " "
  },
  "hr-HR": {
    breadcrumbs: "Navigacijski putovi"
  },
  "hu-HU": {
    breadcrumbs: "Morzsamen"
  },
  "it-IT": {
    breadcrumbs: "Breadcrumb"
  },
  "ja-JP": {
    breadcrumbs: ""
  },
  "ko-KR": {
    breadcrumbs: " "
  },
  "lt-LT": {
    breadcrumbs: "Narymo kelias"
  },
  "lv-LV": {
    breadcrumbs: "Atpakacei"
  },
  "nb-NO": {
    breadcrumbs: "Navigasjonsstier"
  },
  "nl-NL": {
    breadcrumbs: "Broodkruimels"
  },
  "pl-PL": {
    breadcrumbs: "Struktura nawigacyjna"
  },
  "pt-BR": {
    breadcrumbs: "Caminho detalhado"
  },
  "pt-PT": {
    breadcrumbs: "Categorias"
  },
  "ro-RO": {
    breadcrumbs: "Miez de pine"
  },
  "ru-RU": {
    breadcrumbs: ""
  },
  "sk-SK": {
    breadcrumbs: "Navigan prvky Breadcrumbs"
  },
  "sl-SI": {
    breadcrumbs: "Drobtine"
  },
  "sr-SP": {
    breadcrumbs: "Putanje navigacije"
  },
  "sv-SE": {
    breadcrumbs: "Skvgar"
  },
  "tr-TR": {
    breadcrumbs: "erik haritalar"
  },
  "uk-UA": {
    breadcrumbs: " "
  },
  "zh-CN": {
    breadcrumbs: ""
  },
  "zh-TW": {
    breadcrumbs: ""
  }
};

const BreadcrumbsContext = solidJs.createContext();
function useBreadcrumbsContext() {
  const context = solidJs.useContext(BreadcrumbsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useBreadcrumbsContext` must be used within a `Breadcrumbs.Root` component");
  }
  return context;
}

/**
 * Breadcrumbs show hierarchy and navigational context for a users location within an application.
 */
function BreadcrumbsRoot(props) {
  props = utils.mergeDefaultProps({
    separator: "/"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["separator"]);
  const messageFormatter = createMessageFormatter(() => BREADCRUMBS_INTL_MESSAGES);
  const context = {
    separator: () => local.separator
  };
  return web.createComponent(BreadcrumbsContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "nav",
        get ["aria-label"]() {
          return messageFormatter().format("breadcrumbs");
        }
      }, others));
    }
  });
}

/**
 * The visual separator between each breadcrumb items.
 * It will not be visible by screen readers.
 */
function BreadcrumbsSeparator(props) {
  const context = useBreadcrumbsContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get children() {
      return context.separator();
    },
    "aria-hidden": "true"
  }, props));
}

var index$i = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Link: BreadcrumbsLink,
  Root: BreadcrumbsRoot,
  Separator: BreadcrumbsSeparator
});

const CheckboxContext = solidJs.createContext();
function useCheckboxContext() {
  const context = solidJs.useContext(CheckboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCheckboxContext` must be used within a `Checkbox` component");
  }
  return context;
}

/**
 * The element that visually represents a checkbox.
 */
function CheckboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

/**
 * The description that gives the user more information on the checkbox.
 */
function CheckboxDescription(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlDescription, web.mergeProps(() => context.dataset(), props));
}

/**
 * The error message that gives the user information about how to fix a validation error on the checkbox.
 */
function CheckboxErrorMessage(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlErrorMessage, web.mergeProps(() => context.dataset(), props));
}

/**
 * The visual indicator rendered when the checkbox is in a checked or indeterminate state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
function CheckboxIndicator(props) {
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.indeterminate() || context.checked());
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => formControlContext.dataset(), () => context.dataset(), others));
    }
  });
}

const _tmpl$$a = /*#__PURE__*/web.template(`<input type="checkbox">`);
/**
 * The native html input that is visually hidden in the checkbox.
 */
function CheckboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useCheckboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(props, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);

    // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
    // for example a readonly `<input type="checkbox" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
    target.checked = context.checked();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };

  // indeterminate is a property, but it can only be set via javascript
  // https://css-tricks.com/indeterminate-checkboxes/
  // Unlike in React, inputs `indeterminate` state can be out of sync with our.
  // Clicking on the input will change its internal `indeterminate` state.
  // To prevent this, we need to force the input `indeterminate` state to be in sync with our.
  solidJs.createEffect(solidJs.on([() => ref, () => context.indeterminate(), () => context.checked()], ([ref, indeterminate]) => {
    if (ref) {
      ref.indeterminate = !!indeterminate;
    }
  }));
  return (() => {
    const _el$ = _tmpl$$a();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(el => {
      context.setInputRef(el);
      ref = el;
    }, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the checkbox.
 */
function CheckboxLabel(props) {
  const context = useCheckboxContext();
  return web.createComponent(FormControlLabel, web.mergeProps(() => context.dataset(), props));
}

/**
 * A control that allows the user to toggle between checked and not checked.
 */
function CheckboxRoot(props) {
  let ref;
  const defaultId = `checkbox-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(props, ["ref", "children", "value", "checked", "defaultChecked", "indeterminate", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);

    // For consistency with native, prevent the input blurs on pointer down.
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined,
    "data-indeterminate": local.indeterminate ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    indeterminate: () => local.indeterminate ?? false,
    inputRef,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(CheckboxContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return web.createComponent(CheckboxRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function CheckboxRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$h = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Control: CheckboxControl,
  Description: CheckboxDescription,
  ErrorMessage: CheckboxErrorMessage,
  Indicator: CheckboxIndicator,
  Input: CheckboxInput,
  Label: CheckboxLabel,
  Root: CheckboxRoot
});

const PopperContext = solidJs.createContext();
function usePopperContext() {
  const context = solidJs.useContext(PopperContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
  }
  return context;
}

const _tmpl$$9 = /*#__PURE__*/web.template(`<svg display="block" viewBox="0 0 30 30"><g><path fill="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path><path stroke="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z">`);
const DEFAULT_SIZE = 30;
const HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
const ROTATION_DEG = {
  top: 180,
  right: -90,
  bottom: 0,
  left: 90
};
/**
 * An optional arrow element to render alongside the popper content.
 * Must be rendered in the popper content.
 */
function PopperArrow(props) {
  const context = usePopperContext();
  props = utils.mergeDefaultProps({
    size: DEFAULT_SIZE
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "children", "size"]);
  const dir = () => context.currentPlacement().split("-")[0];
  const contentStyle = createComputedStyle(context.contentRef);
  const fill = () => contentStyle()?.getPropertyValue("background-color") || "none";
  const stroke = () => contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
  const borderWidth = () => contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
  const strokeWidth = () => {
    return parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
  };
  const rotate = () => {
    return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE})`;
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setArrowRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-hidden": "true",
    get style() {
      return {
        // server side rendering
        position: "absolute",
        "font-size": `${local.size}px`,
        width: "1em",
        height: "1em",
        "pointer-events": "none",
        fill: fill(),
        stroke: stroke(),
        "stroke-width": strokeWidth(),
        ...local.style
      };
    }
  }, others, {
    get children() {
      const _el$ = _tmpl$$9(),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.firstChild;
        _el$3.nextSibling;
      web.effect(() => web.setAttribute(_el$2, "transform", rotate()));
      return _el$;
    }
  }));
}
function createComputedStyle(element) {
  const [style, setStyle] = solidJs.createSignal();
  solidJs.createEffect(() => {
    const el = element();
    el && setStyle(utils.getWindow(el).getComputedStyle(el));
  });
  return style;
}

/**
 * The wrapper component that positions the popper content relative to the popper anchor.
 */
function PopperPositioner(props) {
  const context = usePopperContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setPositionerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "data-popper-positioner": "",
    get style() {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        "min-width": "max-content",
        ...local.style
      };
    }
  }, others));
}

function createDOMRect(anchorRect) {
  const {
    x = 0,
    y = 0,
    width = 0,
    height = 0
  } = anchorRect ?? {};
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }

  // JSDOM doesn't support DOMRect constructor.
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return {
    ...rect,
    toJSON: () => rect
  };
}
function getAnchorElement(anchor, getAnchorRect) {
  // https://floating-ui.com/docs/virtual-elements
  const contextElement = anchor;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchorRect = getAnchorRect(anchor);
      if (anchorRect) {
        return createDOMRect(anchorRect);
      }
      if (anchor) {
        return anchor.getBoundingClientRect();
      }
      return createDOMRect();
    }
  };
}
function isValidPlacement(flip) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
const REVERSE_BASE_PLACEMENT = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function getTransformOrigin(placement, readingDirection) {
  const [basePlacement, alignment] = placement.split("-");
  const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
  if (!alignment) {
    return `${reversePlacement} center`;
  }
  if (basePlacement === "left" || basePlacement === "right") {
    return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
  }
  if (alignment === "start") {
    return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
  }
  return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}

/**
 * Display a floating content relative to an anchor element with an optional arrow.
 */
function PopperRoot(props) {
  props = utils.mergeDefaultProps({
    getAnchorRect: anchor => anchor?.getBoundingClientRect(),
    placement: "bottom",
    gutter: 0,
    shift: 0,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    hideWhenDetached: false,
    detachedPadding: 0,
    arrowPadding: 4,
    overflowPadding: 8
  }, props);
  const [positionerRef, setPositionerRef] = solidJs.createSignal();
  const [arrowRef, setArrowRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(props.placement);

  // Floating UI - reference element.
  const anchorRef = () => getAnchorElement(props.anchorRef(), props.getAnchorRect);
  const {
    direction
  } = useLocale();
  async function updatePosition() {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    const arrowEl = arrowRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
    const finalGutter = typeof props.gutter === "number" ? props.gutter + arrowOffset : props.gutter ?? arrowOffset;
    floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${props.overflowPadding}px`);

    // Virtual element doesn't work without this \_()_/
    referenceEl.getBoundingClientRect();
    const middleware = [
    // https://floating-ui.com/docs/offset
    dom.offset(({
      placement
    }) => {
      // If there's no placement alignment (*-start or *-end), we'll
      // fall back to the crossAxis offset as it also works for
      // center-aligned placements.
      const hasAlignment = !!placement.split("-")[1];
      return {
        mainAxis: finalGutter,
        crossAxis: !hasAlignment ? props.shift : undefined,
        alignmentAxis: props.shift
      };
    })];
    if (props.flip !== false) {
      const fallbackPlacements = typeof props.flip === "string" ? props.flip.split(" ") : undefined;
      if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) {
        throw new Error("`flip` expects a spaced-delimited list of placements");
      }

      // https://floating-ui.com/docs/flip
      middleware.push(dom.flip({
        padding: props.overflowPadding,
        fallbackPlacements: fallbackPlacements
      }));
    }
    if (props.slide || props.overlap) {
      // https://floating-ui.com/docs/shift
      middleware.push(dom.shift({
        mainAxis: props.slide,
        crossAxis: props.overlap,
        padding: props.overflowPadding
      }));
    }

    // https://floating-ui.com/docs/size
    middleware.push(dom.size({
      padding: props.overflowPadding,
      apply({
        availableWidth,
        availableHeight,
        rects
      }) {
        const referenceWidth = Math.round(rects.reference.width);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
        if (props.sameWidth) {
          floatingEl.style.width = `${referenceWidth}px`;
        }
        if (props.fitViewport) {
          floatingEl.style.maxWidth = `${availableWidth}px`;
          floatingEl.style.maxHeight = `${availableHeight}px`;
        }
      }
    }));

    // https://floating-ui.com/docs/hide
    if (props.hideWhenDetached) {
      middleware.push(dom.hide({
        padding: props.detachedPadding
      }));
    }

    // https://floating-ui.com/docs/arrow
    if (arrowEl) {
      middleware.push(dom.arrow({
        element: arrowEl,
        padding: props.arrowPadding
      }));
    }

    // https://floating-ui.com/docs/computePosition
    const pos = await dom.computePosition(referenceEl, floatingEl, {
      placement: props.placement,
      strategy: "absolute",
      middleware,
      platform: {
        ...dom.platform,
        isRTL: () => direction() === "rtl"
      }
    });

    // Sync the new updated placement of floating-ui with our current placement and notify parent.
    setCurrentPlacement(pos.placement);
    props.onCurrentPlacementChange?.(pos.placement);
    if (!floatingEl) {
      return;
    }
    floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
    const x = Math.round(pos.x);
    const y = Math.round(pos.y);
    let visibility;
    if (props.hideWhenDetached) {
      visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
    }

    // https://floating-ui.com/docs/misc#subpixel-and-accelerated-positioning
    Object.assign(floatingEl.style, {
      top: "0",
      left: "0",
      transform: `translate3d(${x}px, ${y}px, 0)`,
      visibility
    });

    // https://floating-ui.com/docs/arrow#usage
    if (arrowEl && pos.middlewareData.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = pos.middlewareData.arrow;
      const dir = pos.placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        [dir]: "100%"
      });
    }
  }
  solidJs.createEffect(() => {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    if (!referenceEl || !floatingEl) {
      return;
    }

    // https://floating-ui.com/docs/autoUpdate
    const cleanupAutoUpdate = dom.autoUpdate(referenceEl, floatingEl, updatePosition, {
      // JSDOM doesn't support ResizeObserver
      elementResize: typeof ResizeObserver === "function"
    });
    solidJs.onCleanup(cleanupAutoUpdate);
  });

  // Makes sure the positioner element has the same z-index as the popper content element,
  // so users only need to set the z-index once.
  solidJs.createEffect(() => {
    const positioner = positionerRef();
    const content = props.contentRef();
    if (!positioner || !content) {
      return;
    }
    queueMicrotask(() => {
      positioner.style.zIndex = getComputedStyle(content).zIndex;
    });
  });
  const context = {
    currentPlacement,
    contentRef: () => props.contentRef(),
    setPositionerRef,
    setArrowRef
  };
  return web.createComponent(PopperContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

const ComboboxContext = solidJs.createContext();
function useComboboxContext() {
  const context = solidJs.useContext(ComboboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useComboboxContext` must be used within a `Combobox` component");
  }
  return context;
}

/**
 * The component that pops out when the combobox is open.
 */
function ComboboxContent(props) {
  let ref;
  const context = useComboboxContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const close = () => {
    context.close();
    context.resetInputValue();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped (in modal mode), a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => {
      const excludedElements = [];
      if (ref) {
        excludedElements.push(ref);
      }
      const controlEl = context.controlRef();
      if (controlEl) {
        excludedElements.push(controlEl);
      }
      return excludedElements;
    }
  });
  createPreventScroll({
    ownerRef: () => ref,
    isDisabled: () => !(context.isOpen() && (context.isModal() || context.preventScroll()))
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      // We prevent open autofocus because it's handled by the `Listbox`.
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(context.inputRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.controlRef];
            },
            get style() {
              return {
                "--kb-combobox-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: onFocusOutside,
            onDismiss: close
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function ComboboxInput(props) {
  let ref;
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(props, ["ref", "disabled", "onInput", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const collection = () => context.listState().collection();
  const selectionManager = () => context.listState().selectionManager();
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled();
  };
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onInput = e => {
    utils.callHandler(e, local.onInput);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    const target = e.target;
    context.setInputValue(target.value);

    // Unlike in React, inputs `value` can be out of sync with our value state.
    // even if an input is controlled (ex: `<input value="foo" />`,
    // typing on the input will change its internal `value`.
    //
    // To prevent this, we need to force the input `value` to be in sync with the input value state.
    target.value = context.inputValue() ?? "";
    if (!context.isOpen()) {
      context.open(false, "input");
    } else {
      if (collection().getSize() <= 0 && !context.allowsEmptyCollection()) {
        context.close();
      }
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (formControlContext.isReadOnly() || isDisabled()) {
      return;
    }
    if (context.isOpen()) {
      utils.callHandler(e, context.onInputKeyDown);
    }
    switch (e.key) {
      case "Enter":
        // Prevent form submission if menu is open since we may be selecting an option.
        if (context.isOpen()) {
          e.preventDefault();
          const focusedKey = selectionManager().focusedKey();
          if (focusedKey != null) {
            selectionManager().select(focusedKey);
          }
        }
        break;
      case "Tab":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue();
        }
        break;
      case "Escape":
        if (context.isOpen()) {
          context.close();
          context.resetInputValue();
        } else {
          // trigger a remove selection.
          context.setInputValue("");
        }
        break;
      case "ArrowDown":
        if (!context.isOpen()) {
          context.open(e.altKey ? false : "first", "manual");
        }
        break;
      case "ArrowUp":
        if (!context.isOpen()) {
          context.open("last", "manual");
        } else {
          if (e.altKey) {
            context.close();
            context.resetInputValue();
          }
        }
        break;
      case "ArrowLeft":
      case "ArrowRight":
        selectionManager().setFocusedKey(undefined);
        break;
      case "Backspace":
        // Remove last selection in multiple mode if input is empty.
        if (context.removeOnBackspace() && selectionManager().selectionMode() === "multiple" && context.inputValue() === "") {
          const lastSelectedKey = [...selectionManager().selectedKeys()].pop() ?? "";
          selectionManager().toggleSelection(lastSelectedKey);
        }
        break;
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (context.isInputFocused()) {
      return;
    }
    context.setIsInputFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);

    // Ignore blur if focused moved into the control or menu.
    if (utils.contains(context.controlRef(), e.relatedTarget) || utils.contains(context.contentRef(), e.relatedTarget)) {
      return;
    }
    context.setIsInputFocused(false);
  };

  // If a touch happens on direct center of Combobox input, might be virtual click from iPad so open ComboBox menu
  let lastEventTime = 0;
  const onTouchEnd = e => {
    if (!ref || formControlContext.isReadOnly() || isDisabled()) {
      return;
    }

    // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.
    if (e.timeStamp - lastEventTime < 500) {
      e.preventDefault();
      ref.focus();
      return;
    }
    const rect = e.target.getBoundingClientRect();
    const touch = e.changedTouches[0];
    const centerX = Math.ceil(rect.left + 0.5 * rect.width);
    const centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e.preventDefault();
      ref.focus();
      context.toggle(false, "manual");
      lastEventTime = e.timeStamp;
    }
  };

  // Omit `formControlContext.name()` here because it's used in the hidden select.
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "input",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setInputRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get value() {
      return context.inputValue();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get placeholder() {
      return context.placeholder();
    },
    type: "text",
    role: "combobox",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: "false",
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-activedescendant"]() {
      return context.activeDescendant();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    onInput: onInput,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur,
    onTouchEnd: onTouchEnd
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const ListboxContext = solidJs.createContext();
function useListboxContext() {
  const context = solidJs.useContext(ListboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxContext` must be used within a `Listbox` component");
  }
  return context;
}

const ListboxItemContext = solidJs.createContext();
function useListboxItemContext() {
  const context = solidJs.useContext(ListboxItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxItemContext` must be used within a `Listbox.Item` component");
  }
  return context;
}

/**
 * An item of the listbox.
 */
function ListboxItem(props) {
  let ref;
  const listBoxContext = useListboxContext();
  const defaultId = `${listBoxContext.generateId("item")}-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "item", "aria-label", "aria-labelledby", "aria-describedby", "onPointerMove", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const selectionManager = () => listBoxContext.listState().selectionManager();
  const isHighlighted = () => selectionManager().focusedKey() === local.item.key;
  const selectableItem = createSelectableItem({
    key: () => local.item.key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: listBoxContext.shouldSelectOnPressUp,
    allowsDifferentPressOrigin: () => {
      return listBoxContext.shouldSelectOnPressUp() && listBoxContext.shouldFocusOnHover();
    },
    shouldUseVirtualFocus: listBoxContext.shouldUseVirtualFocus,
    disabled: () => local.item.disabled
  }, () => ref);
  const ariaSelected = () => {
    if (selectionManager().selectionMode() === "none") {
      return undefined;
    }
    return selectableItem.isSelected();
  };

  // Safari with VoiceOver on macOS misreads options with aria-labelledby or aria-label as simply "text".
  // We should not map slots to the label and description on Safari and instead just have VoiceOver read the textContent.
  // https://bugs.webkit.org/show_bug.cgi?id=209279
  const isNotSafariMacOS = solidJs.createMemo(() => !(utils.isMac() && utils.isWebKit()));
  const ariaLabel = () => isNotSafariMacOS() ? local["aria-label"] : undefined;
  const ariaLabelledBy = () => isNotSafariMacOS() ? labelId() : undefined;
  const ariaDescribedBy = () => isNotSafariMacOS() ? descriptionId() : undefined;
  const ariaPosInSet = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    const index = listBoxContext.listState().collection().getItem(local.item.key)?.index;
    return index != null ? index + 1 : undefined;
  };
  const ariaSetSize = () => {
    if (!listBoxContext.isVirtualized()) {
      return undefined;
    }
    return getItemCount(listBoxContext.listState().collection());
  };

  /**
   * We focus items on `pointerMove` to achieve the following:
   *
   * - Mouse over an item (it focuses)
   * - Leave mouse where it is and use keyboard to focus a different item
   * - Wiggle mouse without it leaving previously focused item
   * - Previously focused item should re-focus
   *
   * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse
   * wiggles. This is to match native select implementation.
   */
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (!selectableItem.isDisabled() && listBoxContext.shouldFocusOnHover()) {
      utils.focusWithoutScrolling(e.currentTarget);
      selectionManager().setFocused(true);
      selectionManager().setFocusedKey(local.item.key);
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-disabled": selectableItem.isDisabled() ? "" : undefined,
    "data-selected": selectableItem.isSelected() ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isSelected: selectableItem.isSelected,
    dataset,
    generateId: utils.createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(ListboxItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "li",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "option",
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-disabled"]() {
          return selectableItem.isDisabled();
        },
        get ["aria-selected"]() {
          return ariaSelected();
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["aria-posinset"]() {
          return ariaPosInSet();
        },
        get ["aria-setsize"]() {
          return ariaSetSize();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return utils.composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove
      }, dataset, others));
    }
  });
}

/**
 * An optional accessible description to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
function ListboxItemDescription(props) {
  const context = useListboxItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * The visual indicator rendered when the item is selected.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
function ListboxItemIndicator(props) {
  const context = useListboxItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["forceMount"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || context.isSelected();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        "aria-hidden": "true"
      }, () => context.dataset(), others));
    }
  });
}

/**
 * An accessible label to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
function ListboxItemLabel(props) {
  const context = useListboxItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * Listbox presents a list of options and allows a user to select one or more of them.
 */
function ListboxRoot(props) {
  let ref;
  const defaultId = `listbox-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    virtualized: false
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "children", "renderItem", "renderSection", "value", "defaultValue", "onChange", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "state", "keyboardDelegate", "autoFocus", "selectionMode", "shouldFocusWrap", "shouldUseVirtualFocus", "shouldSelectOnPressUp", "shouldFocusOnHover", "allowDuplicateSelectionEvents", "disallowEmptySelection", "selectionBehavior", "selectOnFocus", "disallowTypeAhead", "allowsTabNavigation", "virtualized", "scrollToItem", "scrollRef", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const listState = solidJs.createMemo(() => {
    if (local.state) {
      return local.state;
    }
    return createListState({
      selectedKeys: () => local.value,
      defaultSelectedKeys: () => local.defaultValue,
      onSelectionChange: local.onChange,
      allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
      disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
      selectionBehavior: () => utils.access(local.selectionBehavior),
      selectionMode: () => utils.access(local.selectionMode),
      dataSource: () => local.options ?? [],
      getKey: () => local.optionValue,
      getTextValue: () => local.optionTextValue,
      getDisabled: () => local.optionDisabled,
      getSectionChildren: () => local.optionGroupChildren
    });
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState().selectionManager(),
    collection: () => listState().collection(),
    autoFocus: () => utils.access(local.autoFocus),
    shouldFocusWrap: () => utils.access(local.shouldFocusWrap),
    keyboardDelegate: () => local.keyboardDelegate,
    disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
    selectOnFocus: () => utils.access(local.selectOnFocus),
    disallowTypeAhead: () => utils.access(local.disallowTypeAhead),
    shouldUseVirtualFocus: () => utils.access(local.shouldUseVirtualFocus),
    allowsTabNavigation: () => utils.access(local.allowsTabNavigation),
    isVirtualized: () => local.virtualized,
    scrollToKey: () => local.scrollToItem
  }, () => ref, () => local.scrollRef?.());
  const context = {
    listState,
    generateId: utils.createGenerateId(() => others.id),
    shouldUseVirtualFocus: () => props.shouldUseVirtualFocus,
    shouldSelectOnPressUp: () => props.shouldSelectOnPressUp,
    shouldFocusOnHover: () => props.shouldFocusOnHover,
    isVirtualized: () => local.virtualized
  };
  return web.createComponent(ListboxContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "ul",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "listbox",
        get tabIndex() {
          return selectableList.tabIndex();
        },
        get ["aria-multiselectable"]() {
          return listState().selectionManager().selectionMode() === "multiple" ? true : undefined;
        },
        get onKeyDown() {
          return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
        },
        get onFocusIn() {
          return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
        },
        get onFocusOut() {
          return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
        }
      }, others, {
        get children() {
          return web.createComponent(solidJs.Show, {
            get when() {
              return !local.virtualized;
            },
            get fallback() {
              return local.children?.(listState().collection);
            },
            get children() {
              return web.createComponent(utils.Key, {
                get each() {
                  return [...listState().collection()];
                },
                by: "key",
                children: item => web.createComponent(solidJs.Switch, {
                  get children() {
                    return [web.createComponent(solidJs.Match, {
                      get when() {
                        return item().type === "section";
                      },
                      get children() {
                        return local.renderSection?.(item());
                      }
                    }), web.createComponent(solidJs.Match, {
                      get when() {
                        return item().type === "item";
                      },
                      get children() {
                        return local.renderItem?.(item());
                      }
                    })];
                  }
                })
              });
            }
          });
        }
      }));
    }
  });
}

/**
 * A component used to render the label of a listbox option group.
 * It won't be focusable using arrow keys.
 */
function ListboxSection(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "li",
    role: "presentation"
  }, props));
}

var index$g = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Root: ListboxRoot,
  Section: ListboxSection
});

/**
 * Contains all the items of a `Combobox`.
 */
function ComboboxListbox(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.listboxAriaLabel(), undefined);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerListboxId(others.id)));
  return web.createComponent(ListboxRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get state() {
      return context.listState();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldUseVirtualFocus: true,
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get ["aria-label"]() {
      return context.listboxAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    }
  }, others));
}

/**
 * Portals its children into the `body` when the combobox is open.
 */
function ComboboxPortal(props) {
  const context = useComboboxContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/**
 * Contains the combobox input and trigger.
 */
function ComboboxControl(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setControlRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), () => formControlContext.dataset(), others, {
    get children() {
      return web.createComponent(ComboboxControlChild, {
        state: {
          selectedOptions: () => context.selectedOptions(),
          remove: option => context.removeOptionFromSelection(option),
          clear: () => selectionManager().clearSelection()
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ComboboxControlChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

const _tmpl$$8 = /*#__PURE__*/web.template(`<option>`),
  _tmpl$2 = /*#__PURE__*/web.template(`<div aria-hidden="true"><input type="text"><select tabindex="-1"><option>`);

// In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
// In Firefox, there must be a <label> to identify the <select> whereas other browsers
// seem to identify it just by surrounding text.
// The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
// 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
// non tabbable with tabIndex={-1}.
//
// In mobile browsers, there are next/previous buttons above the software keyboard for navigating
// between fields in a form. These only support native form inputs that are tabbable. In order to
// support those, an additional hidden input is used to marshall focus to the button. It is tabbable
// except when the button is focused, so that shift tab works properly to go to the actual previous
// input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
// the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
// prevent Safari from zooming in on the input when it is focused.
//
// If the current interaction modality is null, then the user hasn't interacted with the page yet.
// In this case, we set the tabIndex to -1 on the input element so that automated accessibility
// checkers don't throw false-positives about focusable elements inside an aria-hidden parent.
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */
function HiddenSelectBase(props) {
  let ref;
  const [local, others] = solidJs.splitProps(props, ["ref", "onChange", "collection", "selectionManager", "isOpen", "isMultiple", "isVirtualized", "focusTrigger"]);
  const formControlContext = useFormControlContext();
  const [isInternalChangeEvent, setIsInternalChangeEvent] = solidJs.createSignal(false);
  const renderOption = key => {
    const item = local.collection.getItem(key);
    return web.createComponent(solidJs.Show, {
      get when() {
        return item?.type === "item";
      },
      get children() {
        const _el$ = _tmpl$$8();
        _el$.value = key;
        web.insert(_el$, () => item?.textValue);
        web.effect(() => _el$.selected = local.selectionManager.isSelected(key));
        return _el$;
      }
    });
  };

  // Dispatch native event on selection change for form libraries.
  solidJs.createEffect(solidJs.on(() => local.selectionManager.selectedKeys(), (keys, prevKeys) => {
    if (prevKeys && isSameSelection(keys, prevKeys)) {
      return;
    }
    setIsInternalChangeEvent(true);
    ref?.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    ref?.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
  }, {
    defer: true
  }));

  // If virtualized, only render the selected options in the hidden <select> so the value can be submitted to a server.
  // Otherwise, render all options so that browser autofill will work.
  return (() => {
    const _el$2 = _tmpl$2(),
      _el$3 = _el$2.firstChild,
      _el$4 = _el$3.nextSibling;
      _el$4.firstChild;
    _el$3.addEventListener("focus", () => local.focusTrigger());
    _el$3.style.setProperty("font-size", "16px");
    _el$4.addEventListener("change", e => {
      utils.callHandler(e, local.onChange);

      // Prevent internally fired change event to update the selection
      // which would result in an infinite loop.
      if (!isInternalChangeEvent()) {
        // enable form autofill
        local.selectionManager.setSelectedKeys(new Set([e.target.value]));
      }
      setIsInternalChangeEvent(false);
    });
    const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$4);
    web.spread(_el$4, web.mergeProps({
      get multiple() {
        return local.isMultiple;
      },
      get name() {
        return formControlContext.name();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get size() {
        return local.collection.getSize();
      },
      get value() {
        return local.selectionManager.firstSelectedKey() ?? "";
      }
    }, others), false, true);
    web.insert(_el$4, web.createComponent(solidJs.Show, {
      get when() {
        return local.isVirtualized;
      },
      get fallback() {
        return web.createComponent(solidJs.For, {
          get each() {
            return [...local.collection.getKeys()];
          },
          children: renderOption
        });
      },
      get children() {
        return web.createComponent(solidJs.For, {
          get each() {
            return [...local.selectionManager.selectedKeys()];
          },
          children: renderOption
        });
      }
    }), null);
    web.effect(_p$ => {
      const _v$ = utils.visuallyHiddenStyles,
        _v$2 = local.selectionManager.isFocused() || local.isOpen ? -1 : 0,
        _v$3 = formControlContext.isRequired(),
        _v$4 = formControlContext.isDisabled(),
        _v$5 = formControlContext.isReadOnly();
      _p$._v$ = web.style(_el$2, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && web.setAttribute(_el$3, "tabindex", _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && (_el$3.required = _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && (_el$3.disabled = _p$._v$4 = _v$4);
      _v$5 !== _p$._v$5 && (_el$3.readOnly = _p$._v$5 = _v$5);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined,
      _v$4: undefined,
      _v$5: undefined
    });
    return _el$2;
  })();
}

function ComboboxHiddenSelect(props) {
  const context = useComboboxContext();
  return web.createComponent(HiddenSelectBase, web.mergeProps({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.inputRef()?.focus()
  }, props));
}

/**
 * A small icon often displayed next to the value as a visual affordance for the fact it can be open.
 * It renders a `` by default, but you can use your own icon `children`.
 */
function ComboboxIcon(props) {
  const context = useComboboxContext();
  props = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), props));
}

const COMBOBOX_INTL_MESSAGES = {
  "ar-AE": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one {# } other {# }} .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText} "
  },
  "bg-BG": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one {# } other {# }}  .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "cs-CZ": {
    triggerLabel: "Zobrazit doporuen",
    countAnnouncement: "K dispozici {optionCount, plural, one {je # monost} other {jsou/je # monosti/-}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true { (vybrno)} other {}}",
    listboxLabel: "Nvrhy",
    selectedAnnouncement: "{optionText}, vybrno"
  },
  "da-DK": {
    triggerLabel: "Vis forslag",
    countAnnouncement: "{optionCount, plural, one {# mulighed tilgngelig} other {# muligheder tilgngelige}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, valgt} other {}}",
    listboxLabel: "Forslag",
    selectedAnnouncement: "{optionText}, valgt"
  },
  "de-DE": {
    triggerLabel: "Empfehlungen anzeigen",
    countAnnouncement: "{optionCount, plural, one {# Option} other {# Optionen}} verfgbar.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, ausgewhlt} other {}}",
    listboxLabel: "Empfehlungen",
    selectedAnnouncement: "{optionText}, ausgewhlt"
  },
  "el-GR": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one {# } other {#  }} .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "en-US": {
    focusAnnouncement: "{optionText}{isSelected, select, true {, selected} other {}}",
    countAnnouncement: "{optionCount, plural, one {# option} other {# options}} available.",
    selectedAnnouncement: "{optionText}, selected",
    triggerLabel: "Show suggestions",
    listboxLabel: "Suggestions"
  },
  "es-ES": {
    triggerLabel: "Mostrar sugerencias",
    countAnnouncement: "{optionCount, plural, one {# opcin} other {# opciones}} disponible(s).",
    focusAnnouncement: "{optionText}{isSelected, select, true {, seleccionado} other {}}",
    listboxLabel: "Sugerencias",
    selectedAnnouncement: "{optionText}, seleccionado"
  },
  "et-EE": {
    triggerLabel: "Kuva soovitused",
    countAnnouncement: "{optionCount, plural, one {# valik} other {# valikud}} saadaval.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, valitud} other {}}",
    listboxLabel: "Soovitused",
    selectedAnnouncement: "{optionText}, valitud"
  },
  "fi-FI": {
    triggerLabel: "Nyt ehdotukset",
    countAnnouncement: "{optionCount, plural, one {# vaihtoehto} other {# vaihtoehdot}} saatavilla.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, valittu} other {}}",
    listboxLabel: "Ehdotukset",
    selectedAnnouncement: "{optionText}, valittu"
  },
  "fr-FR": {
    triggerLabel: "Afficher les suggestions",
    countAnnouncement: "{optionCount, plural, one {# option} other {# options}} disponible(s).",
    focusAnnouncement: "{optionText}{isSelected, select, true {, slectionn(s)} other {}}",
    listboxLabel: "Suggestions",
    selectedAnnouncement: "{optionText}, slectionn"
  },
  "he-IL": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one { #} other {# }}  .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "hr-HR": {
    triggerLabel: "Prikai prijedloge",
    countAnnouncement: "Dostupno jo: {optionCount, plural, one {# opcija} other {# opcije/a}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, odabranih} other {}}",
    listboxLabel: "Prijedlozi",
    selectedAnnouncement: "{optionText}, odabrano"
  },
  "hu-HU": {
    triggerLabel: "Javaslatok megjelentse",
    countAnnouncement: "{optionCount, plural, one {# lehetsg} other {# lehetsg}} ll rendelkezsre.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, kijellve} other {}}",
    listboxLabel: "Javaslatok",
    selectedAnnouncement: "{optionText}, kijellve"
  },
  "it-IT": {
    triggerLabel: "Mostra suggerimenti",
    countAnnouncement: "{optionCount, plural, one {# opzione disponibile} other {# opzioni disponibili}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, selezionato} other {}}",
    listboxLabel: "Suggerimenti",
    selectedAnnouncement: "{optionText}, selezionato"
  },
  "ja-JP": {
    triggerLabel: "",
    countAnnouncement: "{optionCount, plural, one {# } other {# }}",
    focusAnnouncement: "{optionText}{isSelected, select, true {} other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}"
  },
  "ko-KR": {
    triggerLabel: "  ",
    countAnnouncement: "{optionCount, plural, one {# } other {# }}   .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "lt-LT": {
    triggerLabel: "Rodyti pasilymus",
    countAnnouncement: "Yra {optionCount, plural, one {# parinktis} other {# parinktys (-i)}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, pasirinkta} other {}}",
    listboxLabel: "Pasilymai",
    selectedAnnouncement: "{optionText}, pasirinkta"
  },
  "lv-LV": {
    triggerLabel: "Rdt ieteikumus",
    countAnnouncement: "Pieejamo opciju skaits: {optionCount, plural, one {# opcija} other {# opcijas}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, atlasta} other {}}",
    listboxLabel: "Ieteikumi",
    selectedAnnouncement: "{optionText}, atlasta"
  },
  "nb-NO": {
    triggerLabel: "Vis forslag",
    countAnnouncement: "{optionCount, plural, one {# alternativ} other {# alternativer}} finnes.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, valgt} other {}}",
    listboxLabel: "Forslag",
    selectedAnnouncement: "{optionText}, valgt"
  },
  "nl-NL": {
    triggerLabel: "Suggesties weergeven",
    countAnnouncement: "{optionCount, plural, one {# optie} other {# opties}} beschikbaar.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, geselecteerd} other {}}",
    listboxLabel: "Suggesties",
    selectedAnnouncement: "{optionText}, geselecteerd"
  },
  "pl-PL": {
    triggerLabel: "Wywietlaj sugestie",
    countAnnouncement: "dostpna/dostpne(-nych) {optionCount, plural, one {# opcja} other {# opcje(-i)}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, wybrano} other {}}",
    listboxLabel: "Sugestie",
    selectedAnnouncement: "{optionText}, wybrano"
  },
  "pt-BR": {
    triggerLabel: "Mostrar sugestes",
    countAnnouncement: "{optionCount, plural, one {# opo} other {# opes}} disponvel.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, selecionado} other {}}",
    listboxLabel: "Sugestes",
    selectedAnnouncement: "{optionText}, selecionado"
  },
  "pt-PT": {
    triggerLabel: "Apresentar sugestes",
    countAnnouncement: "{optionCount, plural, one {# opo} other {# opes}} disponvel.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, selecionado} other {}}",
    listboxLabel: "Sugestes",
    selectedAnnouncement: "{optionText}, selecionado"
  },
  "ro-RO": {
    triggerLabel: "Afiare sugestii",
    countAnnouncement: "{optionCount, plural, one {# opiune} other {# opiuni}} disponibile.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, selectat} other {}}",
    listboxLabel: "Sugestii",
    selectedAnnouncement: "{optionText}, selectat"
  },
  "ru-RU": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one {# } other {# }} .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "sk-SK": {
    triggerLabel: "Zobrazi nvrhy",
    countAnnouncement: "{optionCount, plural, one {# monos} other {# monosti/-}} k dispozcii.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, vybrat} other {}}",
    listboxLabel: "Nvrhy",
    selectedAnnouncement: "{optionText}, vybrat"
  },
  "sl-SI": {
    triggerLabel: "Prikai predloge",
    countAnnouncement: "Na voljo je {optionCount, plural, one {# opcija} other {# opcije}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, izbrano} other {}}",
    listboxLabel: "Predlogi",
    selectedAnnouncement: "{optionText}, izbrano"
  },
  "sr-SP": {
    triggerLabel: "Prikai predloge",
    countAnnouncement: "Dostupno jo: {optionCount, plural, one {# opcija} other {# opcije/a}}.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, izabranih} other {}}",
    listboxLabel: "Predlozi",
    selectedAnnouncement: "{optionText}, izabrano"
  },
  "sv-SE": {
    triggerLabel: "Visa frslag",
    countAnnouncement: "{optionCount, plural, one {# alternativ} other {# alternativ}} tillgngliga.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, valda} other {}}",
    listboxLabel: "Frslag",
    selectedAnnouncement: "{optionText}, valda"
  },
  "tr-TR": {
    triggerLabel: "nerileri gster",
    countAnnouncement: "{optionCount, plural, one {# seenek} other {# seenekler}} kullanlabilir.",
    focusAnnouncement: "{optionText}{isSelected, select, true {, seildi} other {}}",
    listboxLabel: "neriler",
    selectedAnnouncement: "{optionText}, seildi"
  },
  "uk-UA": {
    triggerLabel: " ",
    countAnnouncement: "{optionCount, plural, one {# } other {# (-)}} .",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "zh-CN": {
    triggerLabel: "",
    countAnnouncement: " {optionCount, plural, one {# } other {# }}",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  },
  "zh-TW": {
    triggerLabel: "",
    countAnnouncement: "{optionCount, plural, one {# } other {# }} ",
    focusAnnouncement: "{optionText}{isSelected, select, true {, } other {}}",
    listboxLabel: "",
    selectedAnnouncement: "{optionText}, "
  }
};

/**
 * Base component for a combobox, provide context for its children.
 */
function ComboboxBase(props) {
  const defaultId = `combobox-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    removeOnBackspace: true,
    gutter: 8,
    sameWidth: true,
    modal: false,
    preventScroll: false,
    triggerMode: "input",
    allowsEmptyCollection: false
  }, props);
  const [local, popperProps, formControlProps, others] = solidJs.splitProps(props, ["itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "onInputChange", "value", "defaultValue", "onChange", "triggerMode", "placeholder", "options", "optionValue", "optionTextValue", "optionLabel", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "shouldFocusWrap", "allowsEmptyCollection", "removeOnBackspace", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [listboxId, setListboxId] = solidJs.createSignal();
  const [controlRef, setControlRef] = solidJs.createSignal();
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [listboxRef, setListboxRef] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(false);
  const [isInputFocused, setIsInputFocusedState] = solidJs.createSignal(false);
  const [lastDisplayedOptions, setLastDisplayedOptions] = solidJs.createSignal(local.options);
  const messageFormatter = createMessageFormatter(() => COMBOBOX_INTL_MESSAGES);

  // Track what action is attempting to open the combobox.
  let openTriggerMode = "focus";
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      // If no `optionValue`, the option itself is the value (ex: string[] of options).
      return String(option);
    }

    // Get the value from the option object as a string.
    return String(utils.isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };
  const getOptionLabel = option => {
    const optionLabel = local.optionLabel;
    if (optionLabel == null) {
      // If no `optionLabel`, the option itself is the label (ex: string[] of options).
      return String(option);
    }

    // Get the label from the option object as a string.
    return String(utils.isFunction(optionLabel) ? optionLabel(option) : option[optionLabel]);
  };

  // Only options without option groups.
  const flattenOptions = solidJs.createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;

    // The combobox doesn't contains option groups.
    if (optionGroupChildren == null) {
      return local.options;
    }
    if (utils.isFunction(optionGroupChildren)) {
      return local.options.flatMap(item => optionGroupChildren(item) ?? item);
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });
  const getOptionsFromValues = values => {
    return [...values].map(value => flattenOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen, openTriggerMode)
  });
  const [inputValue, setInputValue] = createControllableSignal({
    defaultValue: () => "",
    onChange: value => {
      local.onInputChange?.(value);

      // Remove selection when input is cleared and value is uncontrolled (in single selection mode).
      // If controlled, this is the application developer's responsibility.
      if (value === "" && local.selectionMode === "single" && !listState.selectionManager().isEmpty() && local.value === undefined) {
        // Bypass `disallowEmptySelection`.
        listState.selectionManager().setSelectedKeys([]);
      }

      // Clear focused key when input value changes.
      listState.selectionManager().setFocusedKey(undefined);
    }
  });
  const displayedOptions = solidJs.createMemo(() => {
    return disclosureState.isOpen() ? local.options : lastDisplayedOptions();
  });
  const listState = createListState({
    selectedKeys: () => local.value && local.value.map(getOptionValue),
    defaultSelectedKeys: () => local.defaultValue && local.defaultValue.map(getOptionValue),
    onSelectionChange: keys => {
      local.onChange?.(getOptionsFromValues(keys));
      if (local.selectionMode === "single") {
        // Only close if an option is selected.
        // Prevents the combobox to close and reopen when the input is cleared.
        if (disclosureState.isOpen() && keys.size > 0) {
          close();
        }
        resetInputValue();
      } else {
        setInputValue("");
      }
      const inputEl = inputRef();
      if (inputEl) {
        // Move cursor to the end of the input.
        inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
        utils.focusWithoutScrolling(inputEl);
      }
    },
    allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => local.disallowEmptySelection,
    selectionBehavior: () => utils.access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: displayedOptions,
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = solidJs.createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const open = (focusStrategy, triggerMode) => {
    // Don't open if there is no option.
    if (!local.allowsEmptyCollection && local.options.length <= 0) {
      return;
    }
    openTriggerMode = triggerMode;
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    // If combobox is going to close, so we can freeze the displayed options
    // when the user clicks outside the popover to close the combobox.
    // Prevents the popover contents from updating as the combobox closes.
    setLastDisplayedOptions(local.options);
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = (focusStrategy, triggerMode) => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy, triggerMode);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(inputRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });

  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, listboxRef, undefined);
  });

  // Use `createSelectableCollection` to get the keyboard handlers to apply to the input.
  const selectableCollection = createSelectableCollection({
    selectionManager: () => listState.selectionManager(),
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap: () => local.shouldFocusWrap,
    // Prevent item scroll behavior from being applied here, handled in the Listbox component.
    isVirtualized: true
  }, inputRef);
  const setIsInputFocused = isFocused => {
    if (isFocused && local.triggerMode === "focus") {
      open(false, "focus");
    }
    setIsInputFocusedState(isFocused);
    listState.selectionManager().setFocused(isFocused);
  };
  const activeDescendant = solidJs.createMemo(() => {
    const focusedKey = listState.selectionManager().focusedKey();
    if (focusedKey) {
      return listboxRef()?.querySelector(`[data-key="${focusedKey}"]`)?.id;
    }
    return undefined;
  });
  const resetInputValue = () => {
    if (local.selectionMode === "single") {
      const selectedOption = selectedOptions().at(0);
      setInputValue(selectedOption ? getOptionLabel(selectedOption) : "");
    } else {
      setInputValue("");
    }
  };
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };
  solidJs.onMount(() => {
    if (local.selectionMode === "single") {
      // Set input to match current selected key if any.
      resetInputValue();
    }
  });

  // VoiceOver has issues with announcing aria-activedescendant properly on change.
  // We use a live region announcer to announce focus changes manually.
  let lastAnnouncedFocusedKey = "";
  solidJs.createEffect(() => {
    const focusedKey = listState.selectionManager().focusedKey() ?? "";
    const focusedItem = listState.collection().getItem(focusedKey);
    if (utils.isAppleDevice() && focusedItem != null && focusedKey !== lastAnnouncedFocusedKey) {
      const isSelected = listState.selectionManager().isSelected(focusedKey);
      const announcement = messageFormatter().format("focusAnnouncement", {
        optionText: focusedItem?.textValue || "",
        isSelected
      });
      announce(announcement);
    }
    if (focusedKey) {
      lastAnnouncedFocusedKey = focusedKey;
    }
  });

  // Announce the number of available suggestions when it changes.
  let lastOptionCount = getItemCount(listState.collection());
  let lastOpen = disclosureState.isOpen();
  solidJs.createEffect(() => {
    const optionCount = getItemCount(listState.collection());
    const isOpen = disclosureState.isOpen();

    // Only announce the number of options available when the menu opens if there is no
    // focused item, otherwise screen readers will typically read e.g. "1 of 6".
    // The exception is VoiceOver since this isn't included in the message above.
    const didOpenWithoutFocusedItem = isOpen !== lastOpen && (listState.selectionManager().focusedKey() == null || utils.isAppleDevice());
    if (isOpen && (didOpenWithoutFocusedItem || optionCount !== lastOptionCount)) {
      const announcement = messageFormatter().format("countAnnouncement", {
        optionCount
      });
      announce(announcement);
    }
    lastOptionCount = optionCount;
    lastOpen = isOpen;
  });

  // Announce when a selection occurs for VoiceOver.
  // Other screen readers typically do this automatically.
  let lastAnnouncedSelectedKey = "";
  solidJs.createEffect(() => {
    const lastSelectedKey = [...listState.selectionManager().selectedKeys()].pop() ?? "";
    const lastSelectedItem = listState.collection().getItem(lastSelectedKey);
    if (utils.isAppleDevice() && isInputFocused() && lastSelectedItem && lastSelectedKey !== lastAnnouncedSelectedKey) {
      const announcement = messageFormatter().format("selectedAnnouncement", {
        optionText: lastSelectedItem?.textValue || ""
      });
      announce(announcement);
    }
    if (lastSelectedKey) {
      lastAnnouncedSelectedKey = lastSelectedKey;
    }
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => utils.access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? false,
    allowsEmptyCollection: () => local.allowsEmptyCollection ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    removeOnBackspace: () => local.removeOnBackspace ?? true,
    selectedOptions,
    isInputFocused,
    contentPresence,
    autoFocus: focusStrategy,
    inputValue,
    triggerMode: () => local.triggerMode,
    activeDescendant,
    controlRef,
    inputRef,
    triggerRef,
    contentRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    listboxId,
    triggerAriaLabel: () => messageFormatter().format("triggerLabel"),
    listboxAriaLabel: () => messageFormatter().format("listboxLabel"),
    setIsInputFocused,
    resetInputValue,
    setInputValue,
    setControlRef,
    setInputRef,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    onInputKeyDown: e => selectableCollection.onKeyDown(e),
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    registerListboxId: createRegisterId(setListboxId)
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(ComboboxContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: controlRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

/**
 * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.
 */
function ComboboxRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = solidJs.createMemo(() => {
    if (local.value == null) {
      return undefined;
    }
    return local.multiple ? local.value : [local.value];
  });
  const defaultValue = solidJs.createMemo(() => {
    if (local.defaultValue == null) {
      return undefined;
    }
    return local.multiple ? local.defaultValue : [local.defaultValue];
  });
  const onChange = value => {
    local.onChange?.(local.multiple ? value : value[0]);
  };
  return web.createComponent(ComboboxBase, web.mergeProps({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    },
    get disallowEmptySelection() {
      return !local.multiple;
    }
  }, others));
}

function ComboboxTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useComboboxContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "disabled", "onPointerDown", "onClick", "aria-labelledby"]);
  const isDisabled = () => {
    return local.disabled || context.isDisabled() || formControlContext.isDisabled() || formControlContext.isReadOnly();
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;

    // For consistency with native, open the combobox on mouse down (main button), but touch up.
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      // prevent trigger from stealing focus from the active item after opening.
      e.preventDefault();
      context.toggle(false, "manual");
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!isDisabled()) {
      if (e.currentTarget.dataset.pointerType === "touch") {
        context.toggle(false, "manual");
      }

      // Focus the input field in case it isn't focused yet.
      context.inputRef()?.focus();
    }
  };
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(others.id, context.triggerAriaLabel(), local["aria-labelledby"]);
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get disabled() {
      return isDisabled();
    },
    tabIndex: "-1",
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return context.triggerAriaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$f = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: ComboboxContent,
  Control: ComboboxControl,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  HiddenSelect: ComboboxHiddenSelect,
  Icon: ComboboxIcon,
  Input: ComboboxInput,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Label: FormControlLabel,
  Listbox: ComboboxListbox,
  Portal: ComboboxPortal,
  Root: ComboboxRoot,
  Section: ListboxSection,
  Trigger: ComboboxTrigger
});

const MenuContext = solidJs.createContext();
function useOptionalMenuContext() {
  return solidJs.useContext(MenuContext);
}
function useMenuContext() {
  const context = useOptionalMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
  }
  return context;
}

const MenuRootContext = solidJs.createContext();
function useMenuRootContext() {
  const context = solidJs.useContext(MenuRootContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
  }
  return context;
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/menu/src/Menu.tsx
 */
/**
 * Construct a polygon based on pointer clientX/clientY and an element bounding rect.
 */
function getPointerGraceArea(placement, event, contentEl) {
  const basePlacement = placement.split("-")[0];
  const contentRect = contentEl.getBoundingClientRect();
  const polygon = [];
  const pointerX = event.clientX;
  const pointerY = event.clientY;
  switch (basePlacement) {
    case "top":
      polygon.push([pointerX, pointerY + 5]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      break;
    case "right":
      polygon.push([pointerX - 5, pointerY]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      break;
    case "bottom":
      polygon.push([pointerX, pointerY - 5]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      break;
    case "left":
      polygon.push([pointerX + 5, pointerY]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      break;
  }
  return polygon;
}
function isPointerInGraceArea(event, area) {
  if (!area) {
    return false;
  }
  return utils.isPointInPolygon([event.clientX, event.clientY], area);
}

/**
 * Container for menu items and nested menu, provide context for its children.
 */
function Menu(props) {
  const rootContext = useMenuRootContext();
  const parentDomCollectionContext = useOptionalDomCollectionContext();
  const parentMenuContext = useOptionalMenuContext();
  props = utils.mergeDefaultProps({
    placement: "bottom-start"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["open", "defaultOpen", "onOpenChange"]);
  let pointerGraceTimeoutId = 0;
  let pointerGraceIntent = null;
  let pointerDir = "right";
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(true);
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const [nestedMenus, setNestedMenus] = solidJs.createSignal([]);
  const [items, setItems] = solidJs.createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => rootContext.forceMount() || disclosureState.isOpen());
  const listState = createListState({
    selectionMode: "none",
    dataSource: items
  });
  const open = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.open();
  };
  const close = (recursively = false) => {
    disclosureState.close();
    if (recursively && parentMenuContext) {
      parentMenuContext.close(true);
    }
  };
  const toggle = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.toggle();
  };
  const focusContent = () => {
    const content = contentRef();
    if (content) {
      utils.focusWithoutScrolling(content);
      listState.selectionManager().setFocused(true);
      listState.selectionManager().setFocusedKey(undefined);
    }
  };
  const registerNestedMenu = element => {
    setNestedMenus(prev => [...prev, element]);
    const parentUnregister = parentMenuContext?.registerNestedMenu(element);
    return () => {
      setNestedMenus(prev => utils.removeItemFromArray(prev, element));
      parentUnregister?.();
    };
  };
  const isPointerMovingToSubmenu = e => {
    const isMovingTowards = pointerDir === pointerGraceIntent?.side;
    return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
  };
  const onItemEnter = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  const onItemLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    focusContent();
  };
  const onTriggerLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => {
      // Apply only on root menu when opened and modal.
      return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
    },
    targets: () => [contentRef(), ...nestedMenus()].filter(Boolean)
  });
  solidJs.createEffect(() => {
    const contentEl = contentRef();
    if (!contentEl || !parentMenuContext) {
      return;
    }
    const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
    solidJs.onCleanup(() => {
      parentUnregister();
    });
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    currentPlacement,
    pointerGraceTimeoutId: () => pointerGraceTimeoutId,
    autoFocus: focusStrategy,
    listState: () => listState,
    parentMenuContext: () => parentMenuContext,
    triggerRef,
    contentRef,
    triggerId,
    contentId,
    setTriggerRef,
    setContentRef,
    open,
    close,
    toggle,
    focusContent,
    onItemEnter,
    onItemLeave,
    onTriggerLeave,
    setPointerDir: dir => pointerDir = dir,
    setPointerGraceTimeoutId: id => pointerGraceTimeoutId = id,
    setPointerGraceIntent: intent => pointerGraceIntent = intent,
    registerNestedMenu,
    registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(MenuContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: triggerRef,
            contentRef: contentRef,
            onCurrentPlacementChange: setCurrentPlacement
          }, others));
        }
      });
    }
  });
}

const MenuItemContext = solidJs.createContext();
function useMenuItemContext() {
  const context = solidJs.useContext(MenuItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
  }
  return context;
}

/**
 * Base component for a menu item.
 */
function MenuItemBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId(`item-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "textValue", "disabled", "closeOnSelect", "checked", "indeterminate", "onSelect", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [labelRef, setLabelRef] = solidJs.createSignal();
  const selectionManager = () => menuContext.listState().selectionManager();
  const key = () => others.id;
  const isHighlighted = () => selectionManager().focusedKey() === key();
  const onSelect = () => {
    local.onSelect?.();
    if (local.closeOnSelect) {
      menuContext.close(true);
    }
  };
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);

  /**
   * We focus items on `pointerMove` to achieve the following:
   *
   * - Mouse over an item (it focuses)
   * - Leave mouse where it is and use keyboard to focus a different item
   * - Wiggle mouse without it leaving previously focused item
   * - Previously focused item should re-focus
   *
   * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse
   * wiggles. This is to match native menu implementation.
   */
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (local.disabled) {
      menuContext.onItemLeave(e);
    } else {
      menuContext.onItemEnter(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(e.currentTarget);
        menuContext.listState().selectionManager().setFocused(true);
        menuContext.listState().selectionManager().setFocusedKey(key());
      }
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    menuContext.onItemLeave(e);
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);

    // Selection occurs on pointer up (main button).
    if (!local.disabled && e.button === 0) {
      onSelect();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);

    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
        onSelect();
        break;
    }
  };
  const ariaChecked = solidJs.createMemo(() => {
    if (local.indeterminate) {
      return "mixed";
    }
    if (local.checked == null) {
      return undefined;
    }
    return local.checked;
  });
  const dataset = solidJs.createMemo(() => ({
    "data-indeterminate": local.indeterminate ? "" : undefined,
    "data-checked": local.checked && !local.indeterminate ? "" : undefined,
    "data-disabled": local.disabled ? "" : undefined,
    "data-highlighted": isHighlighted() ? "" : undefined
  }));
  const context = {
    isChecked: () => local.checked,
    dataset,
    setLabelRef,
    generateId: utils.createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId)
  };
  return web.createComponent(MenuItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-checked"]() {
          return ariaChecked();
        },
        get ["aria-disabled"]() {
          return local.disabled;
        },
        get ["aria-labelledby"]() {
          return labelId();
        },
        get ["aria-describedby"]() {
          return descriptionId();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return utils.composeEventHandlers([onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return utils.composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return utils.composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove: onPointerMove,
        onPointerLeave: onPointerLeave
      }, dataset, others));
    }
  });
}

/**
 * An item that can be controlled and rendered like a checkbox.
 */
function MenuCheckboxItem(props) {
  props = utils.mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = solidJs.splitProps(props, ["checked", "defaultChecked", "onChange", "onSelect"]);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: checked => local.onChange?.(checked),
    isDisabled: () => others.disabled
  });
  const onSelect = () => {
    local.onSelect?.();
    state.toggle();
  };
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitemcheckbox",
    get checked() {
      return state.isSelected();
    },
    onSelect: onSelect
  }, others));
}

function MenuContentBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId(`content-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onFocusOutside", "onPointerEnter", "onPointerMove", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  let lastPointerX = 0;

  // Only the root menu can apply "modal" behavior (block pointer-events and trap focus).
  const isRootModalContent = () => {
    return context.parentMenuContext() == null && rootContext.isModal();
  };
  const selectableList = createSelectableList({
    selectionManager: context.listState().selectionManager,
    collection: context.listState().collection,
    autoFocus: context.autoFocus,
    deferAutoFocus: true,
    // ensure all menu items are mounted and collection is not empty before trying to autofocus.
    shouldFocusWrap: true,
    disallowTypeAhead: () => !context.listState().selectionManager().isFocused()
  }, () => ref);
  createFocusScope({
    trapFocus: () => isRootModalContent() && context.isOpen(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: local.onCloseAutoFocus
  }, () => ref);
  const onKeyDown = e => {
    // Submenu key events bubble through portals. We only care about keys in this menu.
    if (!utils.contains(e.currentTarget, e.target)) {
      return;
    }

    // Menus should not be navigated using tab key, so we prevent it.
    if (e.key === "Tab" && context.isOpen()) {
      e.preventDefault();
    }
  };
  const onEscapeKeyDown = e => {
    local.onEscapeKeyDown?.(e);

    // `createSelectableList` prevent escape key down,
    // which prevent our `onDismiss` in `DismissableLayer` to run,
    // so we force "close on escape" here.
    context.close(true);
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (rootContext.isModal()) {
      // When focus is trapped, a `focusout` event may still happen.
      // We make sure we don't trigger our `onDismiss` in such case.
      e.preventDefault();
    }
  };
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (!context.isOpen()) {
      return;
    }

    // Remove visual focus from parent menu content.
    context.parentMenuContext()?.listState().selectionManager().setFocused(false);
    context.parentMenuContext()?.listState().selectionManager().setFocusedKey(undefined);
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const target = e.target;
    const pointerXHasChanged = lastPointerX !== e.clientX;

    // We don't use `event.movementX` for this check because Safari will
    // always return `0` on a pointer event.
    if (utils.contains(e.currentTarget, target) && pointerXHasChanged) {
      context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
      lastPointerX = e.clientX;
    }
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(local.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "menu",
            get id() {
              return local.id;
            },
            get tabIndex() {
              return selectableList.tabIndex();
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!isRootModalContent())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            bypassTopMostLayerCheck: true,
            get style() {
              return {
                "--kb-menu-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.triggerId();
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            },
            get onKeyDown() {
              return utils.composeEventHandlers([local.onKeyDown, selectableList.onKeyDown, onKeyDown]);
            },
            get onMouseDown() {
              return utils.composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]);
            },
            get onFocusIn() {
              return utils.composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]);
            },
            get onFocusOut() {
              return utils.composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]);
            },
            onPointerEnter: onPointerEnter,
            onPointerMove: onPointerMove
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function MenuContent(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  createPreventScroll({
    ownerRef: () => ref,
    isDisabled: () => !(context.isOpen() && (rootContext.isModal() || rootContext.preventScroll()))
  });
  return web.createComponent(MenuContentBase, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}

const MenuGroupContext = solidJs.createContext();
function useMenuGroupContext() {
  const context = solidJs.useContext(MenuGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
  }
  return context;
}

/**
 * A container used to group multiple `Menu.Item`s.
 */
function MenuGroup(props) {
  const rootContext = useMenuRootContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId(`group-${solidJs.createUniqueId()}`)
  }, props);
  const [labelId, setLabelId] = solidJs.createSignal();
  const context = {
    generateId: utils.createGenerateId(() => props.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return web.createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, props));
    }
  });
}

/**
 * A component used to render the label of a `Menu.Group`.
 * It won't be focusable using arrow keys.
 */
function MenuGroupLabel(props) {
  const context = useMenuGroupContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
}

/**
 * A small icon often displayed inside the menu trigger as a visual affordance for the fact it can be open.
 * It renders a `` by default, but you can use your own icon by providing a `children`.
 */
function MenuIcon(props) {
  const context = useMenuContext();
  props = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), props));
}

/**
 * An item of the menu.
 */
function MenuItem(props) {
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitem",
    closeOnSelect: true
  }, props));
}

/**
 * An optional accessible description to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
function MenuItemDescription(props) {
  const context = useMenuItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * The visual indicator rendered when the parent menu `CheckboxItem` or `RadioItem` is checked.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
function MenuItemIndicator(props) {
  const context = useMenuItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["forceMount"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return local.forceMount || context.isChecked();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}

/**
 * An accessible label to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
function MenuItemLabel(props) {
  const context = useMenuItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * Portals its children into the `body` when the menu is open.
 */
function MenuPortal(props) {
  const context = useMenuContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

const MenuRadioGroupContext = solidJs.createContext();
function useMenuRadioGroupContext() {
  const context = solidJs.useContext(MenuRadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
  }
  return context;
}

/**
 * A container used to group multiple `Menu.RadioItem`s and manage the selection.
 */
function MenuRadioGroup(props) {
  const rootContext = useMenuRootContext();
  const defaultId = rootContext.generateId(`radiogroup-${solidJs.createUniqueId()}`);
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "disabled"]);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const context = {
    isDisabled: () => local.disabled,
    isSelectedValue: value => value === selected(),
    setSelectedValue: setSelected
  };
  return web.createComponent(MenuRadioGroupContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(MenuGroup, others);
    }
  });
}

/**
 * An item that can be controlled and rendered like a radio.
 */
function MenuRadioItem(props) {
  const context = useMenuRadioGroupContext();
  props = utils.mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "onSelect"]);
  const onSelect = () => {
    local.onSelect?.();
    context.setSelectedValue(local.value);
  };
  return web.createComponent(MenuItemBase, web.mergeProps({
    role: "menuitemradio",
    get checked() {
      return context.isSelectedValue(local.value);
    },
    onSelect: onSelect
  }, others));
}

/**
 * Root component for a menu, provide context for its children.
 * Used to build dropdown menu, context menu and menubar.
 */
function MenuRoot(props) {
  const defaultId = `menu-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    modal: true,
    preventScroll: false
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id", "modal", "preventScroll", "forceMount", "open", "defaultOpen", "onOpenChange"]);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    isModal: () => local.modal ?? true,
    preventScroll: () => local.preventScroll ?? false,
    forceMount: () => local.forceMount ?? false,
    generateId: utils.createGenerateId(() => local.id)
  };
  return web.createComponent(MenuRootContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Menu, web.mergeProps({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        }
      }, others));
    }
  });
}

/**
 * Contains all the parts of a submenu.
 */
function MenuSub(props) {
  const {
    direction
  } = useLocale();
  return web.createComponent(Menu, web.mergeProps({
    get placement() {
      return direction() === "rtl" ? "left-start" : "right-start";
    },
    flip: true
  }, props));
}

const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
/**
 * The component that pops out when a submenu is open.
 */
function MenuSubContent(props) {
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["onFocusOutside", "onKeyDown", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const onOpenAutoFocus = e => {
    // when opening a submenu, focus content for keyboard users only (handled by `MenuSubTrigger`).
    e.preventDefault();
  };
  const onCloseAutoFocus = e => {
    // The menu might close because of focusing another menu item in the parent menu.
    // We don't want it to refocus the trigger in that case, so we handle trigger focus ourselves.
    e.preventDefault();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    const target = e.target;

    // We prevent closing when the trigger is focused to avoid triggering a re-open animation
    // on pointer interaction.
    if (!utils.contains(context.triggerRef(), target)) {
      context.close();
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);

    // Submenu key events bubble through portals. We only care about keys in this menu.
    const isKeyDownInside = utils.contains(e.currentTarget, e.target);
    const isCloseKey = SUB_CLOSE_KEYS[direction()].includes(e.key);
    const isSubMenu = context.parentMenuContext() != null;
    if (isKeyDownInside && isCloseKey && isSubMenu) {
      context.close();

      // We focus manually because we prevented it in `onCloseAutoFocus`.
      utils.focusWithoutScrolling(context.triggerRef());
    }
  };
  return web.createComponent(MenuContentBase, web.mergeProps({
    onOpenAutoFocus: onOpenAutoFocus,
    onCloseAutoFocus: onCloseAutoFocus,
    onFocusOutside: onFocusOutside,
    onKeyDown: onKeyDown
  }, others));
}

const SELECTION_KEYS = ["Enter", " "];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
/**
 * An item that opens a submenu.
 */
function MenuSubTrigger(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId(`sub-trigger-${solidJs.createUniqueId()}`)
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "textValue", "disabled", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  let openTimeoutId = null;
  const clearOpenTimeout = () => {
    if (web.isServer) {
      return;
    }
    if (openTimeoutId) {
      window.clearTimeout(openTimeoutId);
    }
    openTimeoutId = null;
  };
  const {
    direction
  } = useLocale();
  const key = () => local.id;
  const parentSelectionManager = () => {
    const parentMenuContext = context.parentMenuContext();
    if (parentMenuContext == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    return parentMenuContext.listState().selectionManager();
  };
  const collection = () => context.listState().collection();
  const isHighlighted = () => parentSelectionManager().focusedKey() === key();
  const selectableItem = createSelectableItem({
    key,
    selectionManager: parentSelectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!context.isOpen() && !local.disabled) {
      context.open(true);
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const parentMenuContext = context.parentMenuContext();
    parentMenuContext?.onItemEnter(e);
    if (e.defaultPrevented) {
      return;
    }
    if (local.disabled) {
      parentMenuContext?.onItemLeave(e);
      return;
    }
    if (!context.isOpen() && !openTimeoutId) {
      context.parentMenuContext()?.setPointerGraceIntent(null);
      openTimeoutId = window.setTimeout(() => {
        context.open(false);
        clearOpenTimeout();
      }, 100);
    }
    parentMenuContext?.onItemEnter(e);
    if (!e.defaultPrevented) {
      // Remove visual focus from sub menu content.
      if (context.listState().selectionManager().isFocused()) {
        context.listState().selectionManager().setFocused(false);
        context.listState().selectionManager().setFocusedKey(undefined);
      }

      // Restore visual focus to parent menu content.
      utils.focusWithoutScrolling(e.currentTarget);
      parentMenuContext?.listState().selectionManager().setFocused(true);
      parentMenuContext?.listState().selectionManager().setFocusedKey(key());
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    clearOpenTimeout();
    const parentMenuContext = context.parentMenuContext();
    const contentEl = context.contentRef();
    if (contentEl) {
      parentMenuContext?.setPointerGraceIntent({
        area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
        // Safe because sub menu always open "left" or "right".
        side: context.currentPlacement().split("-")[0]
      });
      window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
      const pointerGraceTimeoutId = window.setTimeout(() => {
        parentMenuContext?.setPointerGraceIntent(null);
      }, 300);
      parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
    } else {
      parentMenuContext?.onTriggerLeave(e);
      if (e.defaultPrevented) {
        return;
      }

      // There's 100ms where the user may leave an item before the submenu was opened.
      parentMenuContext?.setPointerGraceIntent(null);
    }
    parentMenuContext?.onItemLeave(e);
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);

    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }

    // For consistency with native, open the menu on key down.
    if (SUB_OPEN_KEYS[direction()].includes(e.key)) {
      e.stopPropagation();
      e.preventDefault();

      // Clear focus on parent menu (e.g. the menu containing the trigger).
      parentSelectionManager().setFocused(false);
      parentSelectionManager().setFocusedKey(undefined);
      if (!context.isOpen()) {
        context.open("first");
      }

      // We focus manually because we prevented it in MenuSubContent's `onOpenAutoFocus`.
      context.focusContent();
      context.listState().selectionManager().setFocused(true);
      context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
    }
  };
  solidJs.createEffect(() => {
    // Not able to register the trigger as a menu item on parent menu means
    // `Menu.SubTrigger` is not used in the correct place, so throw an error.
    if (context.registerItemToParentDomCollection == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }

    // Register the item trigger on the parent menu that contains it.
    const unregister = context.registerItemToParentDomCollection({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    });
    solidJs.onCleanup(unregister);
  });
  solidJs.createEffect(solidJs.on(() => context.parentMenuContext()?.pointerGraceTimeoutId(), pointerGraceTimer => {
    solidJs.onCleanup(() => {
      window.clearTimeout(pointerGraceTimer);
      context.parentMenuContext()?.setPointerGraceIntent(null);
    });
  }));
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(local.id)));
  solidJs.onCleanup(() => {
    clearOpenTimeout();
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    role: "menuitem",
    get tabIndex() {
      return selectableItem.tabIndex();
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["aria-disabled"]() {
      return local.disabled;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([onClick, selectableItem.onClick]);
    },
    get onKeyDown() {
      return utils.composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    onPointerMove: onPointerMove,
    onPointerLeave: onPointerLeave
  }, () => context.dataset(), others));
}

/**
 * The button that toggles the menu.
 */
function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "disabled", "onPointerDown", "onClick", "onKeyDown"]);
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;

    // For consistency with native, open the select on mouse down (main button), but touch up.
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      context.toggle(true);
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!local.disabled && e.currentTarget.dataset.pointerType === "touch") {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }

    // For consistency with native, open the menu on key down.
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
    }
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(local.id)));
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get disabled() {
      return local.disabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), others));
}

/**
 * A separator visually or semantically separates content.
 */
function SeparatorRoot(props) {
  let ref;
  props = utils.mergeDefaultProps({
    orientation: "horizontal"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "orientation"]);
  const tagName = createTagName(() => ref, () => "hr");
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "hr",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "hr" ? "separator" : undefined;
    },
    get ["aria-orientation"]() {
      return local.orientation === "vertical" ? "vertical" : undefined;
    },
    get ["data-orientation"]() {
      return local.orientation;
    }
  }, others));
}

var index$e = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: SeparatorRoot
});

function ContextMenuContent(props) {
  const rootContext = useMenuRootContext();
  const [local, others] = solidJs.splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!e.defaultPrevented && hasInteractedOutside) {
      e.preventDefault();
    }
    hasInteractedOutside = false;
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented && !rootContext.isModal()) {
      hasInteractedOutside = true;
    }
  };
  return web.createComponent(MenuContent, web.mergeProps({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

const ContextMenuContext = solidJs.createContext();
function useOptionalContextMenuContext() {
  return solidJs.useContext(ContextMenuContext);
}
function useContextMenuContext() {
  const context = useOptionalContextMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useContextMenuContext` must be used within a `ContextMenu` component");
  }
  return context;
}

/**
 * Displays a menu located at the pointer, triggered by a right-click or a long-press.
 */
function ContextMenuRoot(props) {
  const defaultId = `contextmenu-${solidJs.createUniqueId()}`;
  const {
    direction
  } = useLocale();
  props = utils.mergeDefaultProps({
    id: defaultId,
    placement: direction() === "rtl" ? "left-start" : "right-start",
    gutter: 2,
    shift: 2
  }, props);
  const [local, others] = solidJs.splitProps(props, ["onOpenChange"]);
  const [anchorRect, setAnchorRect] = solidJs.createSignal({
    x: 0,
    y: 0
  });
  const disclosureState = createDisclosureState({
    defaultOpen: false,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    setAnchorRect
  };
  return web.createComponent(ContextMenuContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(MenuRoot, web.mergeProps({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        },
        getAnchorRect: anchorRect
      }, others));
    }
  });
}

function ContextMenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const context = useContextMenuContext();
  props = utils.mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "disabled", "onContextMenu", "onPointerDown", "onPointerMove", "onPointerCancel", "onPointerUp"]);
  let longPressTimoutId = 0;
  const clearLongPressTimeout = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(longPressTimoutId);
  };
  solidJs.onCleanup(() => {
    clearLongPressTimeout();
  });
  const onContextMenu = e => {
    // If trigger is disabled, enable the native Context Menu.
    if (local.disabled) {
      utils.callHandler(e, local.onContextMenu);
      return;
    }

    // Clearing the long press here because some platforms already support
    // long press to trigger a `contextmenu` event.
    clearLongPressTimeout();
    e.preventDefault();
    context.setAnchorRect({
      x: e.clientX,
      y: e.clientY
    });
    if (menuContext.isOpen()) {
      // If the menu is already open, focus the menu itself.
      menuContext.focusContent();
    } else {
      menuContext.open(true);
    }
  };
  const isTouchOrPen = e => e.pointerType === "touch" || e.pointerType === "pen";
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (!local.disabled && isTouchOrPen(e)) {
      // Clear the long press here in case there's multiple touch points.
      clearLongPressTimeout();
      longPressTimoutId = window.setTimeout(() => menuContext.open(false), 700);
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerCancel = e => {
    utils.callHandler(e, local.onPointerCancel);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    if (!local.disabled && isTouchOrPen(e)) {
      clearLongPressTimeout();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(menuContext.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get style() {
      return {
        // prevent iOS context menu from appearing
        "-webkit-touch-callout": "none",
        ...local.style
      };
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : undefined;
    },
    onContextMenu: onContextMenu,
    onPointerDown: onPointerDown,
    onPointerMove: onPointerMove,
    onPointerCancel: onPointerCancel,
    onPointerUp: onPointerUp
  }, () => menuContext.dataset(), others));
}

var index$d = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: ContextMenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Root: ContextMenuRoot,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: ContextMenuTrigger
});

/**
 * Contains the content to be rendered when the dropdown menu is open.
 */
function DropdownMenuContent(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = solidJs.splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!hasInteractedOutside) {
      utils.focusWithoutScrolling(context.triggerRef());
    }
    hasInteractedOutside = false;

    // Always prevent autofocus because we either focus manually or want user agent focus
    e.preventDefault();
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!rootContext.isModal() || e.detail.isContextMenu) {
      hasInteractedOutside = true;
    }
  };
  return web.createComponent(MenuContent, web.mergeProps({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
}

/**
 * Displays a menu to the user such as a set of actions or functions triggered by a button.
 */
function DropdownMenuRoot(props) {
  const defaultId = `dropdownmenu-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  return web.createComponent(MenuRoot, props);
}

var index$c = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: DropdownMenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Root: DropdownMenuRoot,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: MenuTrigger
});

const HoverCardContext = solidJs.createContext();
function useHoverCardContext() {
  const context = solidJs.useContext(HoverCardContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useHoverCardContext` must be used within a `HoverCard` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the hovercard is open.
 */
function HoverCardContent(props) {
  const context = useHoverCardContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "style"]);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-hovercard-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

/**
 * Portals its children into the `body` when the hovercard is open.
 */
function HoverCardPortal(props) {
  const context = useHoverCardContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */

/**
 * Construct a polygon based on the floating element placement relative to the anchor.
 */
function getHoverCardSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

/**
 * A popover that allows sighted users to preview content available behind a link.
 */
function HoverCardRoot(props) {
  const defaultId = `hovercard-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id", "open", "defaultOpen", "onOpenChange", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let openTimeoutId;
  let closeTimeoutId;
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const {
    addGlobalListener,
    removeGlobalListener
  } = utils.createGlobalListeners();
  const openWithDelay = () => {
    if (web.isServer) {
      return;
    }
    openTimeoutId = window.setTimeout(() => {
      openTimeoutId = undefined;
      disclosureState.open();
    }, local.openDelay);
  };
  const closeWithDelay = () => {
    if (web.isServer) {
      return;
    }
    closeTimeoutId = window.setTimeout(() => {
      closeTimeoutId = undefined;
      disclosureState.close();
    }, local.closeDelay);
  };
  const cancelOpening = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(openTimeoutId);
    openTimeoutId = undefined;
  };
  const cancelClosing = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnHoverCard = target => {
    return utils.contains(triggerRef(), target) || utils.contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getHoverCardSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;

    // Don't close if the mouse is moving through valid hovercard element.
    if (isTargetOnHoverCard(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());

      //Don't close if the current's event mouse position is inside the polygon safe area.
      if (polygon && utils.isPointInPolygon(utils.getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }

    // If there's already a scheduled timeout to hide the hovercard, we do nothing.
    if (closeTimeoutId) {
      return;
    }

    // Otherwise, hide the hovercard after the close delay.
    closeWithDelay();
  };
  solidJs.createEffect(() => {
    if (!disclosureState.isOpen()) {
      return;
    }

    // Checks whether the mouse is moving outside the hovercard.
    // If yes, hide the card after the close delay.
    addGlobalListener(document, "pointermove", onHoverOutside, true);
    solidJs.onCleanup(() => {
      removeGlobalListener(document, "pointermove", onHoverOutside, true);
    });
  });

  // cleanup all timeout on unmount.
  solidJs.onCleanup(() => {
    cancelOpening();
    cancelClosing();
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresence,
    openWithDelay,
    closeWithDelay,
    cancelOpening,
    cancelClosing,
    close: disclosureState.close,
    isTargetOnHoverCard,
    setTriggerRef,
    setContentRef
  };
  return web.createComponent(HoverCardContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

/**
 * The link that opens the hovercard when hovered.
 */
function HoverCardTrigger(props) {
  const context = useHoverCardContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onFocus", "onBlur", "onTouchStart"]);
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    context.cancelOpening();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (others.disabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.cancelOpening();
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnHoverCard(relatedTarget)) {
      return;
    }
    context.closeWithDelay();
  };
  solidJs.onCleanup(context.cancelOpening);
  return web.createComponent(LinkRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index$b = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: HoverCardContent,
  Portal: HoverCardPortal,
  Root: HoverCardRoot,
  Trigger: HoverCardTrigger
});

const ImageContext = solidJs.createContext();
function useImageContext() {
  const context = solidJs.useContext(ImageContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useImageContext` must be used within an `Image.Root` component");
  }
  return context;
}

/**
 * An element that renders when the image hasn't loaded.
 * This means whilst it's loading, or if there was an error.
 */
function ImageFallback(props) {
  const context = useImageContext();
  const [canRender, setCanRender] = solidJs.createSignal(context.fallbackDelay() === undefined);
  solidJs.createEffect(() => {
    const delayMs = context.fallbackDelay();
    if (delayMs !== undefined) {
      const timerId = window.setTimeout(() => setCanRender(true), delayMs);
      solidJs.onCleanup(() => window.clearTimeout(timerId));
    }
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return web.memo(() => !!canRender())() && context.imageLoadingStatus() !== "loaded";
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "span"
      }, props));
    }
  });
}

const _tmpl$$7 = /*#__PURE__*/web.template(`<img>`);
/**
 * The image to render. By default, it will only render when it has loaded.
 */
function ImageImg(props) {
  const context = useImageContext();
  const [loadingStatus, setLoadingStatus] = solidJs.createSignal("idle");
  solidJs.createEffect(solidJs.on(() => props.src, src => {
    if (!src) {
      setLoadingStatus("error");
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = status => () => {
      if (!isMounted) {
        return;
      }
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src;
    solidJs.onCleanup(() => {
      isMounted = false;
    });
  }));
  solidJs.createEffect(() => {
    const imageLoadingStatus = loadingStatus();
    if (imageLoadingStatus !== "idle") {
      context.onImageLoadingStatusChange(imageLoadingStatus);
    }
  });
  return web.createComponent(solidJs.Show, {
    get when() {
      return loadingStatus() === "loaded";
    },
    get children() {
      const _el$ = _tmpl$$7();
      web.spread(_el$, props, false, false);
      return _el$;
    }
  });
}

/**
 * An image element with an optional fallback for loading and error status.
 */
function ImageRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["fallbackDelay", "onLoadingStatusChange"]);
  const [imageLoadingStatus, setImageLoadingStatus] = solidJs.createSignal("idle");
  const context = {
    fallbackDelay: () => local.fallbackDelay,
    imageLoadingStatus,
    onImageLoadingStatusChange: status => {
      setImageLoadingStatus(status);
      local.onLoadingStatusChange?.(status);
    }
  };
  return web.createComponent(ImageContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "span"
      }, others));
    }
  });
}

var index$a = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Fallback: ImageFallback,
  Img: ImageImg,
  Root: ImageRoot
});

const PopoverContext = solidJs.createContext();
function usePopoverContext() {
  const context = solidJs.useContext(PopoverContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopoverContext` must be used within a `Popover` component");
  }
  return context;
}

/**
 * An optional element to position the `Popover.Content` against.
 * If this part is not used, the content will position alongside the `Popover.Trigger`.
 */
function PopoverAnchor(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["ref"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setDefaultAnchorRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, () => context.dataset(), others));
}

/**
 * The button that closes the popover.
 */
function PopoverCloseButton(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const messageFormatter = createMessageFormatter(() => COMMON_INTL_MESSAGES);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || messageFormatter().format("dismiss");
    },
    onClick: onClick
  }, () => context.dataset(), others));
}

/**
 * Contains the content to be rendered when the popover is open.
 */
function PopoverContent(props) {
  let ref;
  const context = usePopoverContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  let hasPointerDownOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        utils.focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          utils.focusWithoutScrolling(context.triggerRef());
        }

        // Always prevent autofocus because we either focus manually or want user agent focus
        e.preventDefault();
      }
      hasInteractedOutside = false;
      hasPointerDownOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (context.isModal()) {
      return;
    }

    // Non-modal behavior below

    if (!e.defaultPrevented) {
      hasInteractedOutside = true;
      if (e.detail.originalEvent.type === "pointerdown") {
        hasPointerDownOutside = true;
      }
    }

    // Prevent dismissing when clicking the trigger.
    // As the trigger is already setup to close, without doing so would
    // cause it to close and immediately open.
    if (utils.contains(context.triggerRef(), e.target)) {
      e.preventDefault();
    }

    // On Safari if the trigger is inside a container with tabIndex={0}, when clicked
    // we will get the pointer down outside event on the trigger, but then a subsequent
    // focus outside event on the container, we ignore any focus outside event when we've
    // already had a pointer down outside event.
    if (e.detail.originalEvent.type === "focusin" && hasPointerDownOutside) {
      e.preventDefault();
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    ownerRef: () => ref,
    isDisabled: () => !(context.isOpen() && (context.isModal() || context.preventScroll()))
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            tabIndex: -1,
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isOpen())() && context.isModal();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-popover-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.titleId();
            },
            get ["aria-describedby"]() {
              return context.descriptionId();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

/**
 * An optional accessible description to be announced when the popover is open.
 */
function PopoverDescription(props) {
  const context = usePopoverContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "p",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * Portals its children into the `body` when the popover is open.
 */
function PopoverPortal(props) {
  const context = usePopoverContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/**
 * A popover is a dialog positioned relative to an anchor element.
 */
function PopoverRoot(props) {
  const defaultId = `popover-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    modal: false,
    preventScroll: false
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id", "open", "defaultOpen", "onOpenChange", "modal", "preventScroll", "forceMount", "anchorRef"]);
  const [defaultAnchorRef, setDefaultAnchorRef] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [contentId, setContentId] = solidJs.createSignal();
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const anchorRef = () => {
    return local.anchorRef?.() ?? defaultAnchorRef() ?? triggerRef();
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? false,
    contentPresence,
    triggerRef,
    contentId,
    titleId,
    descriptionId,
    setDefaultAnchorRef,
    setTriggerRef,
    setContentRef,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    generateId: utils.createGenerateId(() => local.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(PopoverContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: anchorRef,
        contentRef: contentRef
      }, others));
    }
  });
}

/**
 * An accessible title to be announced when the popover is open.
 */
function PopoverTitle(props) {
  const context = usePopoverContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "h2",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * The button that opens the popover.
 */
function PopoverTrigger(props) {
  const context = usePopoverContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onClick", "onPointerDown"]);
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);

    // Prevent popover from opening then closing immediately when inside an overlay in safari.
    e.preventDefault();
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerDown: onPointerDown,
    onClick: onClick
  }, () => context.dataset(), others));
}

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Anchor: PopoverAnchor,
  Arrow: PopperArrow,
  CloseButton: PopoverCloseButton,
  Content: PopoverContent,
  Description: PopoverDescription,
  Portal: PopoverPortal,
  Root: PopoverRoot,
  Title: PopoverTitle,
  Trigger: PopoverTrigger
});

const ProgressContext = solidJs.createContext();
function useProgressContext() {
  const context = solidJs.useContext(ProgressContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useProgressContext` must be used within a `Progress.Root` component");
  }
  return context;
}

/**
 * The component that visually represents the progress value.
 * Used to visually show the fill of `Progress.Track`.
 */
function ProgressFill(props) {
  const context = useProgressContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get style() {
      return {
        "--kb-progress-fill-width": context.progressFillWidth(),
        ...local.style
      };
    }
  }, () => context.dataset(), others));
}

/**
 * An accessible label that gives the user information on the progress.
 */
function ProgressLabel(props) {
  const context = useProgressContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabelId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}

/**
 * Progress show either determinate or indeterminate progress of an operation over time.
 */
function ProgressRoot(props) {
  const defaultId = `progress-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    value: 0,
    minValue: 0,
    maxValue: 100
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "minValue", "maxValue", "indeterminate", "getValueLabel"]);
  const [labelId, setLabelId] = solidJs.createSignal();
  const defaultFormatter = createNumberFormatter(() => ({
    style: "percent"
  }));
  const value = () => {
    return utils.clamp(local.value, local.minValue, local.maxValue);
  };
  const valuePercent = () => {
    return (value() - local.minValue) / (local.maxValue - local.minValue);
  };
  const valueLabel = () => {
    if (local.indeterminate) {
      return undefined;
    }
    if (local.getValueLabel) {
      return local.getValueLabel({
        value: value(),
        min: local.minValue,
        max: local.maxValue
      });
    }
    return defaultFormatter().format(valuePercent());
  };
  const progressFillWidth = () => {
    return local.indeterminate ? undefined : `${Math.round(valuePercent() * 100)}%`;
  };
  const dataset = solidJs.createMemo(() => {
    let dataProgress = undefined;
    if (!local.indeterminate) {
      dataProgress = valuePercent() === 1 ? "complete" : "loading";
    }
    return {
      "data-progress": dataProgress,
      "data-indeterminate": local.indeterminate ? "" : undefined
    };
  });
  const context = {
    dataset,
    value,
    valuePercent,
    valueLabel,
    labelId,
    progressFillWidth,
    generateId: utils.createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return web.createComponent(ProgressContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "progressbar",
        get ["aria-valuenow"]() {
          return web.memo(() => !!local.indeterminate)() ? undefined : value();
        },
        get ["aria-valuemin"]() {
          return local.minValue;
        },
        get ["aria-valuemax"]() {
          return local.maxValue;
        },
        get ["aria-valuetext"]() {
          return valueLabel();
        },
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, dataset, others));
    }
  });
}

/**
 * The component that visually represents the progress track.
 * Act as a container for `Progress.Fill`.
 */
function ProgressTrack(props) {
  const context = useProgressContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), props));
}

/**
 * The accessible label text representing the current value in a human-readable format.
 */
function ProgressValueLabel(props) {
  const context = useProgressContext();
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get children() {
      return context.valueLabel();
    }
  }, () => context.dataset(), props));
}

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Fill: ProgressFill,
  Label: ProgressLabel,
  Root: ProgressRoot,
  Track: ProgressTrack,
  ValueLabel: ProgressValueLabel
});

const RadioGroupContext = solidJs.createContext();
function useRadioGroupContext() {
  const context = solidJs.useContext(RadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupContext` must be used within a `RadioGroup` component");
  }
  return context;
}

const RadioGroupItemContext = solidJs.createContext();
function useRadioGroupItemContext() {
  const context = solidJs.useContext(RadioGroupItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupItemContext` must be used within a `RadioGroup.Item` component");
  }
  return context;
}

/**
 * The root container for a radio button.
 */
function RadioGroupItem(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const defaultId = `${formControlContext.generateId("item")}-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "disabled", "onPointerDown"]);
  const [inputId, setInputId] = solidJs.createSignal();
  const [labelId, setLabelId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const isSelected = solidJs.createMemo(() => {
    return radioGroupContext.isSelectedValue(local.value);
  });
  const isDisabled = solidJs.createMemo(() => {
    return local.disabled || formControlContext.isDisabled() || false;
  });
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);

    // For consistency with native, prevent the input blurs on pointer down.
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    ...formControlContext.dataset(),
    "data-disabled": isDisabled() ? "" : undefined,
    "data-checked": isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    isSelected,
    isDisabled,
    inputId,
    labelId,
    descriptionId,
    inputRef,
    select: () => radioGroupContext.setSelectedValue(local.value),
    generateId: utils.createGenerateId(() => others.id),
    registerInput: createRegisterId(setInputId),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(RadioGroupItemContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        role: "group",
        onPointerDown: onPointerDown
      }, dataset, others));
    }
  });
}

/**
 * The element that visually represents a radio button.
 */
function RadioGroupItemControl(props) {
  const context = useRadioGroupItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.select();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.select();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => context.dataset(), others));
}

/**
 * The description that gives the user more information on the radio button.
 */
function RadioGroupItemDescription(props) {
  const context = useRadioGroupItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescription(props.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => context.dataset(), props));
}

/**
 * The visual indicator rendered when the radio item is in a checked state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
function RadioGroupItemIndicator(props) {
  const context = useRadioGroupItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "forceMount"]);
  const presence = createPresence(() => local.forceMount || context.isSelected());
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, () => context.dataset(), others));
    }
  });
}

const _tmpl$$6 = /*#__PURE__*/web.template(`<input type="radio">`);
/**
 * The native html input that is visually hidden in the radio button.
 */
function RadioGroupItemInput(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const radioContext = useRadioGroupItemContext();
  props = utils.mergeDefaultProps({
    id: radioContext.generateId("input")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "style", "aria-labelledby", "aria-describedby", "onChange", "onFocus", "onBlur"]);
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"], radioContext.labelId(),
    // If there is both an aria-label and aria-labelledby, add the input itself has an aria-labelledby
    local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const ariaDescribedBy = () => {
    return [local["aria-describedby"], radioContext.descriptionId(), radioGroupContext.ariaDescribedBy()].filter(Boolean).join(" ") || undefined;
  };
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    radioGroupContext.setSelectedValue(radioContext.value());
    const target = e.target;

    // Unlike in React, inputs `checked` state can be out of sync with our state.
    // for example a readonly `<input type="radio" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="radio" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with our state.
    target.checked = radioContext.isSelected();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    radioContext.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    radioContext.setIsFocused(false);
  };
  solidJs.createEffect(() => solidJs.onCleanup(radioContext.registerInput(others.id)));
  return (() => {
    const _el$ = _tmpl$$6();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(radioContext.setInputRef, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return radioContext.value();
      },
      get checked() {
        return radioContext.isSelected();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return radioContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return ariaDescribedBy();
      }
    }, () => radioContext.dataset(), others), false, false);
    return _el$;
  })();
}

const _tmpl$$5 = /*#__PURE__*/web.template(`<label>`);
/**
 * The label that gives the user information on the radio button.
 */
function RadioGroupItemLabel(props) {
  const context = useRadioGroupItemContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerLabel(props.id)));
  return (() => {
    const _el$ = _tmpl$$5();
    web.spread(_el$, web.mergeProps({
      get ["for"]() {
        return context.inputId();
      }
    }, () => context.dataset(), props), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the radio group.
 */
function RadioGroupLabel(props) {
  return web.createComponent(FormControlLabel, web.mergeProps({
    as: "span"
  }, props));
}

/**
 * A set of checkable buttons, known as radio buttons, where no more than one of the buttons can be checked at a time.
 * This component is based on the [WAI-ARIA Radio Group Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/)
 */
function RadioGroupRoot(props) {
  let ref;
  const defaultId = `radiogroup-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    orientation: "vertical"
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(props, ["ref", "value", "defaultValue", "onChange", "orientation", "aria-labelledby", "aria-describedby"], FORM_CONTROL_PROP_NAMES);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setSelected(local.defaultValue ?? ""));
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(utils.access(formControlProps.id), others["aria-label"], local["aria-labelledby"]);
  };
  const ariaDescribedBy = () => {
    return formControlContext.getAriaDescribedBy(local["aria-describedby"]);
  };
  const isSelectedValue = value => {
    return value === selected();
  };
  const context = {
    ariaDescribedBy,
    isSelectedValue,
    setSelectedValue: value => {
      if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
        return;
      }
      setSelected(value);

      // Sync all radio input checked state in the group with the selected value.
      // This is necessary because checked state might be out of sync
      // (ex: when using controlled radio-group).
      ref?.querySelectorAll("[type='radio']").forEach(el => {
        const radio = el;
        radio.checked = isSelectedValue(radio.value);
      });
    }
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(RadioGroupContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "radiogroup",
            get id() {
              return utils.access(formControlProps.id);
            },
            get ["aria-invalid"]() {
              return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"]() {
              return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"]() {
              return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"]() {
              return formControlContext.isReadOnly() || undefined;
            },
            get ["aria-orientation"]() {
              return local.orientation;
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            get ["aria-describedby"]() {
              return ariaDescribedBy();
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Item: RadioGroupItem,
  ItemControl: RadioGroupItemControl,
  ItemDescription: RadioGroupItemDescription,
  ItemIndicator: RadioGroupItemIndicator,
  ItemInput: RadioGroupItemInput,
  ItemLabel: RadioGroupItemLabel,
  Label: RadioGroupLabel,
  Root: RadioGroupRoot
});

const SelectContext = solidJs.createContext();
function useSelectContext() {
  const context = solidJs.useContext(SelectContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSelectContext` must be used within a `Select` component");
  }
  return context;
}

/**
 * The component that pops out when the select is open.
 */
function SelectContent(props) {
  let ref;
  const context = useSelectContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "style", "onCloseAutoFocus", "onFocusOutside"]);
  const onEscapeKeyDown = e => {
    // `createSelectableList` prevent escape key down,
    // which prevent our `onDismiss` in `DismissableLayer` to run,
    // so we force "close on escape" here.
    context.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped (in modal mode), a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.isOpen() && context.isModal()) {
      e.preventDefault();
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    ownerRef: () => ref,
    isDisabled: () => !(context.isOpen() && (context.isModal() || context.preventScroll()))
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: e => {
      // We prevent open autofocus because it's handled by the `Listbox`.
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      local.onCloseAutoFocus?.(e);
      if (!e.defaultPrevented) {
        utils.focusWithoutScrolling(context.triggerRef());
        e.preventDefault();
      }
    }
  }, () => ref);
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get disableOutsidePointerEvents() {
              return web.memo(() => !!context.isModal())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                "--kb-select-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            }
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

function SelectHiddenSelect(props) {
  const context = useSelectContext();
  return web.createComponent(HiddenSelectBase, web.mergeProps({
    get collection() {
      return context.listState().collection();
    },
    get selectionManager() {
      return context.listState().selectionManager();
    },
    get isOpen() {
      return context.isOpen();
    },
    get isMultiple() {
      return context.isMultiple();
    },
    get isVirtualized() {
      return context.isVirtualized();
    },
    focusTrigger: () => context.triggerRef()?.focus()
  }, props));
}

/**
 * A small icon often displayed next to the value as a visual affordance for the fact it can be open.
 * It renders a `` by default, but you can use your own icon `children`.
 */
function SelectIcon(props) {
  const context = useSelectContext();
  props = utils.mergeDefaultProps({
    children: ""
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), props));
}

/**
 * The label that gives the user information on the select.
 */
function SelectLabel(props) {
  const context = useSelectContext();
  const [local, others] = solidJs.splitProps(props, ["onClick"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!context.isDisabled()) {
      context.triggerRef()?.focus();
    }
  };
  return web.createComponent(FormControlLabel, web.mergeProps({
    as: "span",
    onClick: onClick
  }, others));
}

/**
 * Contains all the items of a `Select`.
 */
function SelectListbox(props) {
  const context = useSelectContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("listbox")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "onKeyDown"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerListboxId(local.id)));

  /*
  onMount(() => {
    if (!context.isOpen() || context.autoFocus() === false) {
      return;
    }
     let focusedKey = context.listState().selectionManager().firstSelectedKey();
     if (focusedKey == null) {
      if (context.autoFocus() === "first") {
        focusedKey = context.listState().collection().getFirstKey();
      } else if (context.autoFocus() === "last") {
        focusedKey = context.listState().collection().getLastKey();
      }
    }
     context.listState().selectionManager().setFocused(true);
    context.listState().selectionManager().setFocusedKey(focusedKey);
  });
  */

  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);

    // Prevent from clearing the selection by `createSelectableCollection` on escape.
    if (e.key === "Escape" && context.isMultiple()) {
      e.preventDefault();
    }
  };
  return web.createComponent(ListboxRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get state() {
      return context.listState();
    },
    get virtualized() {
      return context.isVirtualized();
    },
    get autoFocus() {
      return context.autoFocus();
    },
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get shouldFocusWrap() {
      return context.shouldFocusWrap();
    },
    get disallowTypeAhead() {
      return context.disallowTypeAhead();
    },
    get ["aria-labelledby"]() {
      return context.listboxAriaLabelledBy();
    },
    get renderItem() {
      return context.renderItem;
    },
    get renderSection() {
      return context.renderSection;
    },
    onKeyDown: onKeyDown
  }, others));
}

/**
 * Portals its children into the `body` when the select is open.
 */
function SelectPortal(props) {
  const context = useSelectContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/**
 * Base component for a select, provide context for its children.
 * Used to build single and multi-select.
 */
function SelectBase(props) {
  const defaultId = `select-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    gutter: 8,
    sameWidth: true,
    modal: false,
    preventScroll: false
  }, props);
  const [local, popperProps, formControlProps, others] = solidJs.splitProps(props, ["itemComponent", "sectionComponent", "open", "defaultOpen", "onOpenChange", "value", "defaultValue", "onChange", "placeholder", "options", "optionValue", "optionTextValue", "optionDisabled", "optionGroupChildren", "keyboardDelegate", "allowDuplicateSelectionEvents", "disallowEmptySelection", "disallowTypeAhead", "shouldFocusWrap", "selectionBehavior", "selectionMode", "virtualized", "modal", "preventScroll", "forceMount"], ["getAnchorRect", "placement", "gutter", "shift", "flip", "slide", "overlap", "sameWidth", "fitViewport", "hideWhenDetached", "detachedPadding", "arrowPadding", "overflowPadding"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = solidJs.createSignal();
  const [valueId, setValueId] = solidJs.createSignal();
  const [listboxId, setListboxId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [listboxRef, setListboxRef] = solidJs.createSignal();
  const [listboxAriaLabelledBy, setListboxAriaLabelledBy] = solidJs.createSignal();
  const [focusStrategy, setFocusStrategy] = solidJs.createSignal(true);
  const getOptionValue = option => {
    const optionValue = local.optionValue;
    if (optionValue == null) {
      // If no `optionValue`, the option itself is the value (ex: string[] of options)
      return String(option);
    }

    // Get the value from the option object as a string.
    return String(utils.isFunction(optionValue) ? optionValue(option) : option[optionValue]);
  };

  // Only options without option groups.
  const flattenOptions = solidJs.createMemo(() => {
    const optionGroupChildren = local.optionGroupChildren;

    // The combobox doesn't contains option groups.
    if (optionGroupChildren == null) {
      return local.options;
    }
    if (utils.isFunction(optionGroupChildren)) {
      return local.options.flatMap(item => optionGroupChildren(item) ?? item);
    }
    return local.options.flatMap(item => item[optionGroupChildren] ?? item);
  });

  // Only option keys without option groups.
  const flattenOptionKeys = solidJs.createMemo(() => {
    return flattenOptions().map(option => getOptionValue(option));
  });
  const getOptionsFromValues = values => {
    return [...values].map(value => flattenOptions().find(option => getOptionValue(option) === value)).filter(option => option != null);
  };
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const listState = createListState({
    selectedKeys: () => local.value && local.value.map(getOptionValue),
    defaultSelectedKeys: () => local.defaultValue && local.defaultValue.map(getOptionValue),
    onSelectionChange: keys => {
      local.onChange?.(getOptionsFromValues(keys));
      if (local.selectionMode === "single") {
        close();
      }
    },
    allowDuplicateSelectionEvents: () => utils.access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => utils.access(local.disallowEmptySelection),
    selectionBehavior: () => utils.access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: () => local.options ?? [],
    getKey: () => local.optionValue,
    getTextValue: () => local.optionTextValue,
    getDisabled: () => local.optionDisabled,
    getSectionChildren: () => local.optionGroupChildren
  });
  const selectedOptions = solidJs.createMemo(() => {
    return getOptionsFromValues(listState.selectionManager().selectedKeys());
  });
  const removeOptionFromSelection = option => {
    listState.selectionManager().toggleSelection(getOptionValue(option));
  };
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const focusListbox = () => {
    const listboxEl = listboxRef();
    if (listboxEl) {
      utils.focusWithoutScrolling(listboxEl);
    }
  };
  const open = focusStrategy => {
    // Don't open if there is no option.
    if (local.options.length <= 0) {
      return;
    }
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    focusListbox();
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
  };
  const toggle = focusStrategy => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy);
    }
  };
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(triggerRef, () => {
    const defaultSelectedKeys = local.defaultValue ? [...local.defaultValue].map(getOptionValue) : new Selection();
    listState.selectionManager().setSelectedKeys(defaultSelectedKeys);
  });
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });

  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  const delegate = solidJs.createMemo(() => {
    const keyboardDelegate = utils.access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, undefined, collator);
  });
  const renderItem = item => {
    return local.itemComponent?.({
      item
    });
  };
  const renderSection = section => {
    return local.sectionComponent?.({
      section
    });
  };

  // Delete selected keys that do not match any option in the listbox.
  solidJs.createEffect(solidJs.on([flattenOptionKeys], ([flattenOptionKeys]) => {
    const currentSelectedKeys = [...listState.selectionManager().selectedKeys()];
    const keysToKeep = currentSelectedKeys.filter(key => flattenOptionKeys.includes(key));
    listState.selectionManager().setSelectedKeys(keysToKeep);
  }, {
    defer: true
  }));
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => utils.access(local.selectionMode) === "multiple",
    isVirtualized: () => local.virtualized ?? false,
    isModal: () => local.modal ?? false,
    preventScroll: () => local.preventScroll ?? false,
    disallowTypeAhead: () => local.disallowTypeAhead ?? false,
    shouldFocusWrap: () => local.shouldFocusWrap ?? false,
    selectedOptions,
    contentPresence,
    autoFocus: focusStrategy,
    triggerRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    triggerId,
    valueId,
    listboxId,
    listboxAriaLabelledBy,
    setListboxAriaLabelledBy,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    placeholder: () => local.placeholder,
    renderItem,
    renderSection,
    removeOptionFromSelection,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerValueId: createRegisterId(setValueId),
    registerListboxId: createRegisterId(setListboxId)
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(SelectContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(PopperRoot, web.mergeProps({
            anchorRef: triggerRef,
            contentRef: contentRef
          }, popperProps, {
            get children() {
              return web.createComponent(Polymorphic, web.mergeProps({
                as: "div",
                role: "group",
                get id() {
                  return utils.access(formControlProps.id);
                }
              }, () => formControlContext.dataset(), dataset, others));
            }
          }));
        }
      });
    }
  });
}

/**
 * Displays a list of options for the user to pick from  triggered by a button.
 */
function SelectRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "multiple"]);
  const value = solidJs.createMemo(() => {
    if (local.value == null) {
      return undefined;
    }
    return local.multiple ? local.value : [local.value];
  });
  const defaultValue = solidJs.createMemo(() => {
    if (local.defaultValue == null) {
      return undefined;
    }
    return local.multiple ? local.defaultValue : [local.defaultValue];
  });
  const onChange = value => {
    local.onChange?.(local.multiple ? value : value[0]);
  };
  return web.createComponent(SelectBase, web.mergeProps({
    get value() {
      return value();
    },
    get defaultValue() {
      return defaultValue();
    },
    onChange: onChange,
    get selectionMode() {
      return local.multiple ? "multiple" : "single";
    },
    get disallowEmptySelection() {
      return !local.multiple;
    }
  }, others));
}

function SelectTrigger(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(props, ["ref", "disabled", "onPointerDown", "onClick", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const selectionManager = () => context.listState().selectionManager();
  const keyboardDelegate = () => context.keyboardDelegate();
  const isDisabled = () => local.disabled || context.isDisabled();
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const {
    typeSelectHandlers
  } = createTypeSelect({
    keyboardDelegate: keyboardDelegate,
    selectionManager: selectionManager,
    onTypeSelect: key => selectionManager().select(key)
  });
  const ariaLabelledBy = () => {
    return [context.listboxAriaLabelledBy(), context.valueId()].filter(Boolean).join(" ") || undefined;
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;

    // For consistency with native, open the select on mouse down (main button), but touch up.
    if (!isDisabled() && e.pointerType !== "touch" && e.button === 0) {
      // prevent trigger from stealing focus from the active item after opening.
      e.preventDefault();
      context.toggle(true);
    }
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    if (!isDisabled() && e.currentTarget.dataset.pointerType === "touch") {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (isDisabled()) {
      return;
    }
    utils.callHandler(e, typeSelectHandlers.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowLeft":
        {
          // prevent scrolling containers
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyAbove?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
      case "ArrowRight":
        {
          // prevent scrolling containers
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyBelow?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
    }
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (selectionManager().isFocused()) {
      return;
    }
    selectionManager().setFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    if (context.isOpen()) {
      return;
    }
    selectionManager().setFocused(false);
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTriggerId(fieldProps.id())));
  solidJs.createEffect(() => {
    context.setListboxAriaLabelledBy([fieldProps.ariaLabelledBy(), fieldProps.ariaLabel() && !fieldProps.ariaLabelledBy() ? fieldProps.id() : null].filter(Boolean).join(" ") || undefined);
  });
  return web.createComponent(ButtonRoot, web.mergeProps({
    ref(r$) {
      const _ref$ = utils.mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get disabled() {
      return isDisabled();
    },
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return web.memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    onPointerDown: onPointerDown,
    onClick: onClick,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), () => formControlContext.dataset(), others));
}

const _tmpl$$4 = /*#__PURE__*/web.template(`<span>`);
/**
 * The part that reflects the selected value(s).
 */
function SelectValue(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("value")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id", "children"]);
  const selectionManager = () => context.listState().selectionManager();
  const isSelectionEmpty = () => {
    const selectedKeys = selectionManager().selectedKeys();

    // Some form libraries uses an empty string as default value, often taken from an empty `<option />`.
    // Ignore since it is not a valid key.
    if (selectedKeys.size === 1 && selectedKeys.has("")) {
      return true;
    }
    return selectionManager().isEmpty();
  };
  solidJs.createEffect(() => solidJs.onCleanup(context.registerValueId(local.id)));
  return (() => {
    const _el$ = _tmpl$$4();
    web.spread(_el$, web.mergeProps({
      get id() {
        return local.id;
      },
      get ["data-placeholder-shown"]() {
        return isSelectionEmpty() ? "" : undefined;
      }
    }, () => formControlContext.dataset(), others), false, true);
    web.insert(_el$, web.createComponent(solidJs.Show, {
      get when() {
        return !isSelectionEmpty();
      },
      get fallback() {
        return context.placeholder();
      },
      get children() {
        return web.createComponent(SelectValueChild, {
          state: {
            selectedOption: () => context.selectedOptions()[0],
            selectedOptions: () => context.selectedOptions(),
            remove: option => context.removeOptionFromSelection(option),
            clear: () => selectionManager().clearSelection()
          },
          get children() {
            return local.children;
          }
        });
      }
    }));
    return _el$;
  })();
}
function SelectValueChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: SelectContent,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  HiddenSelect: SelectHiddenSelect,
  Icon: SelectIcon,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Label: SelectLabel,
  Listbox: SelectListbox,
  Portal: SelectPortal,
  Root: SelectRoot,
  Section: ListboxSection,
  Trigger: SelectTrigger,
  Value: SelectValue
});

const SwitchContext = solidJs.createContext();
function useSwitchContext() {
  const context = solidJs.useContext(SwitchContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSwitchContext` must be used within a `Switch` component");
  }
  return context;
}

/**
 * The element that visually represents a switch.
 */
function SwitchControl(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("control")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["onClick", "onKeyDown"]);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.toggle();
    context.inputRef()?.focus();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key === utils.EventKey.Space) {
      context.toggle();
      context.inputRef()?.focus();
    }
  };
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    onClick: onClick,
    onKeyDown: onKeyDown
  }, () => formControlContext.dataset(), () => context.dataset(), others));
}

/**
 * The description that gives the user more information on the switch.
 */
function SwitchDescription(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlDescription, web.mergeProps(() => context.dataset(), props));
}

/**
 * The error message that gives the user information about how to fix a validation error on the switch.
 */
function SwitchErrorMessage(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlErrorMessage, web.mergeProps(() => context.dataset(), props));
}

const _tmpl$$3 = /*#__PURE__*/web.template(`<input type="checkbox" role="switch">`);
/**
 * The native html input that is visually hidden in the switch.
 */
function SwitchInput(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(props, ["ref", "style", "onChange", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const onChange = e => {
    utils.callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);

    // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
    // for example a readonly `<input type="checkbox" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
    target.checked = context.checked();
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    context.setIsFocused(true);
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    context.setIsFocused(false);
  };
  return (() => {
    const _el$ = _tmpl$$3();
    _el$.addEventListener("blur", onBlur);
    _el$.addEventListener("focus", onFocus);
    _el$.addEventListener("change", onChange);
    const _ref$ = utils.mergeRefs(context.setInputRef, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, web.mergeProps({
      get id() {
        return fieldProps.id();
      },
      get name() {
        return formControlContext.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.checked();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return formControlContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...utils.visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-label"]() {
        return fieldProps.ariaLabel();
      },
      get ["aria-labelledby"]() {
        return fieldProps.ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return fieldProps.ariaDescribedBy();
      },
      get ["aria-invalid"]() {
        return formControlContext.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return formControlContext.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return formControlContext.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return formControlContext.isReadOnly() || undefined;
      }
    }, () => formControlContext.dataset(), () => context.dataset(), others), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the switch.
 */
function SwitchLabel(props) {
  const context = useSwitchContext();
  return web.createComponent(FormControlLabel, web.mergeProps(() => context.dataset(), props));
}

/**
 * A control that allows users to choose one of two values: on or off.
 */
function SwitchRoot(props) {
  let ref;
  const defaultId = `switch-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(props, ["ref", "children", "value", "checked", "defaultChecked", "onChange", "onPointerDown"], FORM_CONTROL_PROP_NAMES);
  const [inputRef, setInputRef] = solidJs.createSignal();
  const [isFocused, setIsFocused] = solidJs.createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => formControlContext.isDisabled(),
    isReadOnly: () => formControlContext.isReadOnly()
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultChecked ?? false));
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);

    // For consistency with native, prevent the input blurs on pointer down.
    if (isFocused()) {
      e.preventDefault();
    }
  };
  const dataset = solidJs.createMemo(() => ({
    "data-checked": state.isSelected() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    checked: () => state.isSelected(),
    inputRef,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    toggle: () => state.toggle(),
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setInputRef
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(SwitchContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            },
            onPointerDown: onPointerDown
          }, () => formControlContext.dataset(), dataset, others, {
            get children() {
              return web.createComponent(SwitchRootChild, {
                state: context,
                get children() {
                  return local.children;
                }
              });
            }
          }));
        }
      });
    }
  });
}
function SwitchRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

/**
 * The thumb that is used to visually indicate whether the switch is on or off.
 */
function SwitchThumb(props) {
  const formControlContext = useFormControlContext();
  const context = useSwitchContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("thumb")
  }, props);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div"
  }, () => formControlContext.dataset(), () => context.dataset(), props));
}

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Control: SwitchControl,
  Description: SwitchDescription,
  ErrorMessage: SwitchErrorMessage,
  Input: SwitchInput,
  Label: SwitchLabel,
  Root: SwitchRoot,
  Thumb: SwitchThumb
});

const TabsContext = solidJs.createContext();
function useTabsContext() {
  const context = solidJs.useContext(TabsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTabsContext` must be used within a `Tabs` component");
  }
  return context;
}

/**
 * Contains the content associated with a tab trigger.
 */
function TabsContent(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "value", "forceMount"]);
  const [tabIndex, setTabIndex] = solidJs.createSignal(0);
  const id = () => local.id ?? context.generateContentId(local.value);
  const isSelected = () => context.listState().selectedKey() === local.value;
  const presence = createPresence(() => local.forceMount || isSelected());
  solidJs.createEffect(solidJs.on([() => ref, () => presence.isPresent()], ([ref, isPresent]) => {
    if (ref == null || !isPresent) {
      return;
    }
    const updateTabIndex = () => {
      // Detect if there are any tabbable elements and update the tabIndex accordingly.
      const walker = utils.getFocusableTreeWalker(ref, {
        tabbable: true
      });
      setTabIndex(walker.nextNode() ? undefined : 0);
    };
    updateTabIndex();
    const observer = new MutationObserver(updateTabIndex);

    // Update when new elements are inserted, or the tabindex/disabled attribute updates.
    observer.observe(ref, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["tabindex", "disabled"]
    });
    solidJs.onCleanup(() => {
      observer.disconnect();
    });
  }));
  solidJs.createEffect(solidJs.on([() => local.value, id], ([value, id]) => {
    context.contentIdsMap().set(value, id);
  }));
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(Polymorphic, web.mergeProps({
        as: "div",
        ref(r$) {
          const _ref$ = utils.mergeRefs(el => {
            presence.setRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return id();
        },
        role: "tabpanel",
        get tabIndex() {
          return tabIndex();
        },
        get ["aria-labelledby"]() {
          return context.triggerIdsMap().get(local.value);
        },
        get ["data-orientation"]() {
          return context.orientation();
        },
        get ["data-selected"]() {
          return isSelected() ? "" : undefined;
        }
      }, others));
    }
  });
}

/**
 * The visual indicator displayed at the bottom of the tab list to indicate the selected tab.
 * It provides the base style needed to display a smooth transition to the new selected tab.
 */
function TabsIndicator(props) {
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  const [style, setStyle] = solidJs.createSignal({
    width: undefined,
    height: undefined
  });
  const {
    direction
  } = useLocale();
  const computeStyle = () => {
    const selectedTab = context.selectedTab();
    if (selectedTab == null) {
      return;
    }
    const styleObj = {
      transform: undefined,
      width: undefined,
      height: undefined
    };

    // In RTL, calculate the transform from the right edge of the tab list
    // so that resizing the window doesn't break the TabIndicator position due to offsetLeft changes
    const offset = direction() === "rtl" ? -1 * (selectedTab.offsetParent?.offsetWidth - selectedTab.offsetWidth - selectedTab.offsetLeft) : selectedTab.offsetLeft;
    styleObj.transform = context.orientation() === "vertical" ? `translateY(${selectedTab.offsetTop}px)` : `translateX(${offset}px)`;
    if (context.orientation() === "horizontal") {
      styleObj.width = `${selectedTab.offsetWidth}px`;
    } else {
      styleObj.height = `${selectedTab.offsetHeight}px`;
    }
    setStyle(styleObj);
  };

  // For the first run, wait for all tabs to be mounted and registered in tabs DOM collection
  // before computing the style.
  solidJs.onMount(() => {
    queueMicrotask(() => {
      computeStyle();
    });
  });

  // Compute style normally for subsequent runs.
  solidJs.createEffect(solidJs.on([context.selectedTab, context.orientation, direction], () => {
    computeStyle();
  }, {
    defer: true
  }));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    role: "presentation",
    get style() {
      return {
        ...style(),
        ...local.style
      };
    },
    get ["data-orientation"]() {
      return context.orientation();
    }
  }, others));
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/6b51339cca0b8344507d3c8e81e7ad05d6e75f9b/packages/@react-aria/tabs/src/TabsKeyboardDelegate.ts
 */

class TabsKeyboardDelegate {
  constructor(collection, direction, orientation) {
    this.collection = collection;
    this.direction = direction;
    this.orientation = orientation;
  }
  flipDirection() {
    return this.direction() === "rtl" && this.orientation() === "horizontal";
  }
  getKeyLeftOf(key) {
    if (this.flipDirection()) {
      return this.getNextKey(key);
    } else {
      if (this.orientation() === "horizontal") {
        return this.getPreviousKey(key);
      }
      return undefined;
    }
  }
  getKeyRightOf(key) {
    if (this.flipDirection()) {
      return this.getPreviousKey(key);
    } else {
      if (this.orientation() === "horizontal") {
        return this.getNextKey(key);
      }
      return undefined;
    }
  }
  getKeyAbove(key) {
    if (this.orientation() === "vertical") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyBelow(key) {
    if (this.orientation() === "vertical") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getNextKey(key);
    }
    return key;
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.disabled) {
      key = this.getPreviousKey(key);
    }
    return key;
  }
  getNextKey(key) {
    let nextKey = key;
    let nextItem;
    do {
      nextKey = this.collection().getKeyAfter(nextKey) ?? this.collection().getFirstKey();
      if (nextKey == null) {
        return;
      }
      nextItem = this.collection().getItem(nextKey);
      if (nextItem == null) {
        return;
      }
    } while (nextItem.disabled);
    return nextKey;
  }
  getPreviousKey(key) {
    let previousKey = key;
    let previousItem;
    do {
      previousKey = this.collection().getKeyBefore(previousKey) ?? this.collection().getLastKey();
      if (previousKey == null) {
        return;
      }
      previousItem = this.collection().getItem(previousKey);
      if (previousItem == null) {
        return;
      }
    } while (previousItem.disabled);
    return previousKey;
  }
}

/**
 * Contains the tabs that are aligned along the edge of the active tab panel.
 */
function TabsList(props) {
  let ref;
  const context = useTabsContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const delegate = new TabsKeyboardDelegate(() => context.listState().collection(), direction, context.orientation);
  const selectableCollection = createSelectableCollection({
    selectionManager: () => context.listState().selectionManager(),
    keyboardDelegate: () => delegate,
    selectOnFocus: () => context.activationMode() === "automatic",
    shouldFocusWrap: false,
    // handled by the keyboard delegate
    disallowEmptySelection: true
  }, () => ref);
  solidJs.createEffect(() => {
    if (ref == null) {
      return;
    }
    const selectedTab = ref.querySelector(`[data-key="${context.listState().selectedKey()}"]`);
    if (selectedTab != null) {
      context.setSelectedTab(selectedTab);
    }
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "tablist",
    get ["aria-orientation"]() {
      return context.orientation();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get onKeyDown() {
      return utils.composeEventHandlers([local.onKeyDown, selectableCollection.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableCollection.onMouseDown]);
    },
    get onFocusIn() {
      return utils.composeEventHandlers([local.onFocusIn, selectableCollection.onFocusIn]);
    },
    get onFocusOut() {
      return utils.composeEventHandlers([local.onFocusOut, selectableCollection.onFocusOut]);
    }
  }, others));
}

/**
 * A set of layered sections of content, known as tab panels, that display one panel of content at a time.
 * `Tabs` contains all the parts of a tabs component and provide context for its children.
 */
function TabsRoot(props) {
  const defaultId = `tabs-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    orientation: "horizontal",
    activationMode: "automatic"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["value", "defaultValue", "onChange", "orientation", "activationMode", "disabled"]);
  const [items, setItems] = solidJs.createSignal([]);
  const [selectedTab, setSelectedTab] = solidJs.createSignal();
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createSingleSelectListState({
    selectedKey: () => local.value,
    defaultSelectedKey: () => local.defaultValue,
    onSelectionChange: key => local.onChange?.(String(key)),
    dataSource: items
  });
  let lastSelectedKey = listState.selectedKey();
  solidJs.createEffect(solidJs.on([() => listState.selectionManager(), () => listState.collection(), () => listState.selectedKey()], ([selectionManager, collection, currentSelectedKey]) => {
    let selectedKey = currentSelectedKey;

    // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)
    if (selectionManager.isEmpty() || selectedKey == null || !collection.getItem(selectedKey)) {
      selectedKey = collection.getFirstKey();
      let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;

      // loop over tabs until we find one that isn't disabled and select that
      while (selectedItem?.disabled && selectedItem.key !== collection.getLastKey()) {
        selectedKey = collection.getKeyAfter(selectedItem.key);
        selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      }

      // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last
      if (selectedItem?.disabled && selectedKey === collection.getLastKey()) {
        selectedKey = collection.getFirstKey();
      }

      // directly set selection because replace/toggle selection won't consider disabled keys
      if (selectedKey != null) {
        selectionManager.setSelectedKeys([selectedKey]);
      }
    }

    // If there isn't a focused key yet or the tabs doesn't have focus and the selected key changes,
    // change focused key to the selected key if it exists.
    if (selectionManager.focusedKey() == null || !selectionManager.isFocused() && selectedKey !== lastSelectedKey) {
      selectionManager.setFocusedKey(selectedKey);
    }
    lastSelectedKey = selectedKey;
  }));

  // associated value/trigger ids
  const triggerIdsMap = new Map();

  // associated value/content ids
  const contentIdsMap = new Map();
  const context = {
    isDisabled: () => local.disabled ?? false,
    orientation: () => local.orientation,
    activationMode: () => local.activationMode,
    triggerIdsMap: () => triggerIdsMap,
    contentIdsMap: () => contentIdsMap,
    listState: () => listState,
    selectedTab,
    setSelectedTab,
    generateTriggerId: value => `${others.id}-trigger-${value}`,
    generateContentId: value => `${others.id}-content-${value}`
  };
  return web.createComponent(DomCollectionProvider, {
    get children() {
      return web.createComponent(TabsContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            get ["data-orientation"]() {
              return context.orientation();
            }
          }, others));
        }
      });
    }
  });
}

/**
 * The button that activates its associated tab panel.
 */
function TabsTrigger(props) {
  let ref;
  const context = useTabsContext();
  props = utils.mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "id", "value", "disabled", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const id = () => local.id ?? context.generateTriggerId(local.value);
  const isHighlighted = () => context.listState().selectionManager().focusedKey() === local.value;
  const isDisabled = () => local.disabled || context.isDisabled();
  const contentId = () => context.contentIdsMap().get(local.value);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: local.value,
      textValue: "",
      // not applicable here
      disabled: isDisabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => local.value,
    selectionManager: () => context.listState().selectionManager(),
    disabled: isDisabled
  }, () => ref);
  const onClick = e => {
    // Force focusing the trigger on click on safari.
    if (utils.isWebKit()) {
      utils.focusWithoutScrolling(e.currentTarget);
    }
  };
  solidJs.createEffect(solidJs.on([() => local.value, id], ([value, id]) => {
    context.triggerIdsMap().set(value, id);
  }));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return id();
    },
    role: "tab",
    get tabIndex() {
      return web.memo(() => !!!isDisabled())() ? selectableItem.tabIndex() : undefined;
    },
    get disabled() {
      return isDisabled();
    },
    get ["aria-selected"]() {
      return selectableItem.isSelected();
    },
    get ["aria-disabled"]() {
      return isDisabled() || undefined;
    },
    get ["aria-controls"]() {
      return web.memo(() => !!selectableItem.isSelected())() ? contentId() : undefined;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get ["data-selected"]() {
      return selectableItem.isSelected() ? "" : undefined;
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return isDisabled() ? "" : undefined;
    },
    get onPointerDown() {
      return utils.composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return utils.composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return utils.composeEventHandlers([local.onClick, selectableItem.onClick, onClick]);
    },
    get onKeyDown() {
      return utils.composeEventHandlers([local.onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return utils.composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return utils.composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    }
  }, others));
}

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: TabsContent,
  Indicator: TabsIndicator,
  List: TabsList,
  Root: TabsRoot,
  Trigger: TabsTrigger
});

const TextFieldContext = solidJs.createContext();
function useTextFieldContext() {
  const context = solidJs.useContext(TextFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTextFieldContext` must be used within a `TextField` component");
  }
  return context;
}

/**
 * The native html input of the textfield.
 */
function TextFieldInput(props) {
  return web.createComponent(TextFieldInputBase, web.mergeProps({
    type: "text"
  }, props));
}
function TextFieldInputBase(props) {
  const formControlContext = useFormControlContext();
  const context = useTextFieldContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = solidJs.splitProps(props, ["onInput"], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "input",
    get id() {
      return fieldProps.id();
    },
    get name() {
      return formControlContext.name();
    },
    get value() {
      return context.value();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    get onInput() {
      return utils.composeEventHandlers([local.onInput, context.onInput]);
    }
  }, () => formControlContext.dataset(), others));
}

/**
 * A text input that allow users to input custom text entries with a keyboard.
 */
function TextFieldRoot(props) {
  let ref;
  const defaultId = `textfield-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, formControlProps, others] = solidJs.splitProps(props, ["ref", "value", "defaultValue", "onChange"], FORM_CONTROL_PROP_NAMES);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setValue(local.defaultValue ?? ""));
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    setValue(target.value);

    // Unlike in React, inputs `value` can be out of sync with our value state.
    // even if an input is controlled (ex: `<input value="foo" />`,
    // typing on the input will change its internal `value`.
    //
    // To prevent this, we need to force the input `value` to be in sync with the text field value state.
    target.value = value() ?? "";
  };
  const context = {
    value,
    generateId: utils.createGenerateId(() => utils.access(formControlProps.id)),
    onInput
  };
  return web.createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return web.createComponent(TextFieldContext.Provider, {
        value: context,
        get children() {
          return web.createComponent(Polymorphic, web.mergeProps({
            as: "div",
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get id() {
              return utils.access(formControlProps.id);
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
}

/**
 * The native html textarea of the textfield.
 */
function TextFieldTextArea(props) {
  let ref;
  const context = useTextFieldContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("textarea")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "autoResize", "submitOnEnter", "onKeyPress"]);
  solidJs.createEffect(solidJs.on([() => ref, () => local.autoResize, () => context.value()], ([ref, autoResize]) => {
    if (!ref || !autoResize) {
      return;
    }
    adjustHeight(ref);
  }));
  const onKeyPress = event => {
    if (ref && local.submitOnEnter && event.key === "Enter" && !event.shiftKey) {
      if (ref.form) {
        ref.form.requestSubmit();
        event.preventDefault();
      }
    }
  };
  return web.createComponent(TextFieldInputBase, web.mergeProps({
    as: "textarea",
    get ["aria-multiline"]() {
      return local.submitOnEnter ? "false" : undefined;
    },
    get onKeyPress() {
      return utils.composeEventHandlers([local.onKeyPress, onKeyPress]);
    },
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}

/**
 * Adjust the height of the textarea based on its text value.
 */
function adjustHeight(el) {
  const prevAlignment = el.style.alignSelf;
  const prevOverflow = el.style.overflow;

  // Firefox scroll position is lost when `overflow: 'hidden'` is applied, so we skip applying it.
  // The measure/applied height is also incorrect/reset if we turn on and off
  // overflow: hidden in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1787062
  const isFirefox = ("MozAppearance" in el.style);
  if (!isFirefox) {
    el.style.overflow = "hidden";
  }
  el.style.alignSelf = "start";
  el.style.height = "auto";

  // offsetHeight - clientHeight accounts for the border/padding.
  el.style.height = `${el.scrollHeight + (el.offsetHeight - el.clientHeight)}px`;
  el.style.overflow = prevOverflow;
  el.style.alignSelf = prevAlignment;
}

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Input: TextFieldInput,
  Label: FormControlLabel,
  Root: TextFieldRoot,
  TextArea: TextFieldTextArea
});

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/tree/main/packages/%40react-aria/toast/intl
 */

const TOAST_HOTKEY_PLACEHOLDER = "{hotkey}";
const TOAST_INTL_MESSAGES = {
  "ar-AE": {
    close: "",
    notifications: `(${TOAST_HOTKEY_PLACEHOLDER}) ` + ""
  },
  "bg-BG": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "cs-CZ": {
    close: "Zavt",
    notifications: `Upozornn (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "da-DK": {
    close: "Luk",
    notifications: `Pmindelser (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "de-DE": {
    close: "Schlieen",
    notifications: `Benachrichtigungen (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "el-GR": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "en-US": {
    close: "Close",
    notifications: `Notifications (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "es-ES": {
    close: "Cerrar",
    notifications: `Notificaciones (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "et-EE": {
    close: "Sule",
    notifications: `Teated (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "fi-FI": {
    close: "Sulje",
    notifications: `Ilmoitukset (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "fr-FR": {
    close: "Fermer",
    notifications: `Notifications (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "he-IL": {
    close: "",
    notifications: `(${TOAST_HOTKEY_PLACEHOLDER}) ` + ""
  },
  "hr-HR": {
    close: "Zatvori",
    notifications: `Obavijesti (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "hu-HU": {
    close: "Bezrs",
    notifications: `rtestsek (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "it-IT": {
    close: "Chiudi",
    notifications: `Notifiche (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "ja-JP": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "ko-KR": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "lt-LT": {
    close: "Udaryti",
    notifications: `Praneimai (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "lv-LV": {
    close: "Aizvrt",
    notifications: `Paziojumi (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "nb-NO": {
    close: "Lukk",
    notifications: `Varsler (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "nl-NL": {
    close: "Sluiten",
    notifications: `Meldingen (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "pl-PL": {
    close: "Zamknij",
    notifications: `Powiadomienia (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "pt-BR": {
    close: "Fechar",
    notifications: `Notificaes (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "pt-PT": {
    close: "Fechar",
    notifications: `Notificaes (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "ro-RO": {
    close: "nchidei",
    notifications: `Notificri (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "ru-RU": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "sk-SK": {
    close: "Zatvori",
    notifications: `Oznmenia (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "sl-SI": {
    close: "Zapri",
    notifications: `Obvestila (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "sr-SP": {
    close: "Zatvori",
    notifications: `Obavetenja (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "sv-SE": {
    close: "Stng",
    notifications: `Aviseringar (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "tr-TR": {
    close: "Kapat",
    notifications: `Bildirimler (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "uk-UA": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "zh-CN": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  },
  "zh-TW": {
    close: "",
    notifications: ` (${TOAST_HOTKEY_PLACEHOLDER})`
  }
};

const ToastContext = solidJs.createContext();
function useToastContext() {
  const context = solidJs.useContext(ToastContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastContext` must be used within a `Toast.Root` component");
  }
  return context;
}

/**
 * The button that closes the toast.
 */
function ToastCloseButton(props) {
  const context = useToastContext();
  const [local, others] = solidJs.splitProps(props, ["aria-label", "onClick"]);
  const messageFormatter = createMessageFormatter(() => TOAST_INTL_MESSAGES);
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    context.close();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-label"]() {
      return local["aria-label"] || messageFormatter().format("close");
    },
    onClick: onClick
  }, others));
}

/**
 * An optional accessible description to be announced when the toast is open.
 */
function ToastDescription(props) {
  const context = useToastContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerDescriptionId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

const ToastRegionContext = solidJs.createContext();
function useToastRegionContext() {
  const context = solidJs.useContext(ToastRegionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useToastRegionContext` must be used within a `Toast.Region` component");
  }
  return context;
}

const _tmpl$$2 = /*#__PURE__*/web.template(`<ol tabindex="-1">`);
/**
 * The list containing all rendered toasts.
 * Must be inside a `Toast.Region`.
 */
function ToastList(props) {
  let ref;
  const context = useToastRegionContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onFocusIn", "onFocusOut", "onPointerMove", "onPointerLeave"]);
  const onFocusIn = e => {
    utils.callHandler(e, local.onFocusIn);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onFocusOut = e => {
    utils.callHandler(e, local.onFocusOut);

    // The newly focused element isn't inside the toast list.
    if (!utils.contains(ref, e.relatedTarget)) {
      context.resumeAllTimer();
    }
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (context.pauseOnInteraction() && !context.isPaused()) {
      context.pauseAllTimer();
    }
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);

    // The current active element isn't inside the toast list.
    if (!utils.contains(ref, utils.getDocument(ref).activeElement)) {
      context.resumeAllTimer();
    }
  };
  solidJs.createEffect(solidJs.on([() => ref, () => context.hotkey()], ([ref, hotkey]) => {
    if (!ref) {
      return;
    }
    const doc = utils.getDocument(ref);
    const onKeyDown = event => {
      const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);
      if (isHotkeyPressed) {
        utils.focusWithoutScrolling(ref);
      }
    };
    doc.addEventListener("keydown", onKeyDown);
    solidJs.onCleanup(() => doc.removeEventListener("keydown", onKeyDown));
  }));
  solidJs.createEffect(() => {
    if (!context.pauseOnPageIdle()) {
      return;
    }
    const win = utils.getWindow(ref);
    win.addEventListener("blur", context.pauseAllTimer);
    win.addEventListener("focus", context.resumeAllTimer);
    solidJs.onCleanup(() => {
      win.removeEventListener("blur", context.pauseAllTimer);
      win.removeEventListener("focus", context.resumeAllTimer);
    });
  });
  return (() => {
    const _el$ = _tmpl$$2();
    _el$.addEventListener("pointerleave", onPointerLeave);
    _el$.$$pointermove = onPointerMove;
    _el$.$$focusout = onFocusOut;
    _el$.$$focusin = onFocusIn;
    const _ref$ = utils.mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && web.use(_ref$, _el$);
    web.spread(_el$, others, false, true);
    web.insert(_el$, web.createComponent(solidJs.For, {
      get each() {
        return context.toasts();
      },
      children: toast => toast.toastComponent({
        get toastId() {
          return toast.id;
        }
      })
    }));
    return _el$;
  })();
}
web.delegateEvents(["focusin", "focusout", "pointermove"]);

/**
 * The component that visually represents the toast remaining lifetime.
 * Used to visually show the fill of `Toast.ProgressTrack`.
 */
function ToastProgressFill(props) {
  const rootContext = useToastRegionContext();
  const context = useToastContext();
  const [local, others] = solidJs.splitProps(props, ["style"]);
  const [lifeTime, setLifeTime] = solidJs.createSignal(100);
  let totalElapsedTime = 0;
  solidJs.createEffect(() => {
    if (rootContext.isPaused() || context.isPersistent()) {
      return;
    }
    const intervalId = setInterval(() => {
      const elapsedTime = new Date().getTime() - context.closeTimerStartTime() + totalElapsedTime;
      const life = Math.trunc(100 - elapsedTime / context.duration() * 100);
      setLifeTime(life < 0 ? 0 : life);
    });
    solidJs.onCleanup(() => {
      totalElapsedTime += new Date().getTime() - context.closeTimerStartTime();
      clearInterval(intervalId);
    });
  });
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get style() {
      return {
        "--kb-toast-progress-fill-width": `${lifeTime()}%`,
        ...local.style
      };
    }
  }, others));
}

/**
 * The component that visually represents the toast lifetime.
 * Act as a container for `Toast.ProgressFill`.
 */
function ToastProgressTrack(props) {
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    "aria-hidden": "true",
    role: "presentation"
  }, props));
}

const _tmpl$$1 = /*#__PURE__*/web.template(`<div role="region" tabindex="-1">`);
/**
 * The fixed area where toasts appear. Users can jump to by pressing a hotkey.
 * It is up to you to ensure the discoverability of the hotkey for keyboard users.
 */
function ToastRegion(props) {
  const defaultId = `toast-region-${solidJs.createUniqueId()}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    hotkey: ["altKey", "KeyT"],
    duration: 5000,
    limit: 3,
    swipeDirection: "right",
    swipeThreshold: 50,
    pauseOnInteraction: true,
    pauseOnPageIdle: true,
    topLayer: true
  }, props);
  const [local, others] = solidJs.splitProps(props, ["style", "hotkey", "duration", "limit", "swipeDirection", "swipeThreshold", "pauseOnInteraction", "pauseOnPageIdle", "topLayer", "aria-label", "regionId"]);
  const toasts = solidJs.createMemo(() => toastStore.toasts().filter(toast => toast.region === local.regionId).slice(0, local.limit));
  const [isPaused, setIsPaused] = solidJs.createSignal(false);
  const messageFormatter = createMessageFormatter(() => TOAST_INTL_MESSAGES);
  const hasToasts = () => toasts().length > 0;
  const hotkeyLabel = () => {
    return local.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
  };
  const ariaLabel = () => {
    const label = local["aria-label"] || messageFormatter().format("notifications", {
      hotkey: hotkeyLabel()
    });
    return label.replace(TOAST_HOTKEY_PLACEHOLDER, hotkeyLabel());
  };
  const topLayerAttr = () => ({
    [DATA_TOP_LAYER_ATTR]: local.topLayer ? "" : undefined
  });
  const context = {
    isPaused,
    toasts,
    hotkey: () => local.hotkey,
    duration: () => local.duration,
    swipeDirection: () => local.swipeDirection,
    swipeThreshold: () => local.swipeThreshold,
    pauseOnInteraction: () => local.pauseOnInteraction,
    pauseOnPageIdle: () => local.pauseOnPageIdle,
    pauseAllTimer: () => setIsPaused(true),
    resumeAllTimer: () => setIsPaused(false),
    generateId: utils.createGenerateId(() => others.id)
  };
  return web.createComponent(ToastRegionContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$$1();
      web.spread(_el$, web.mergeProps({
        get ["aria-label"]() {
          return ariaLabel();
        },
        get style() {
          return {
            "pointer-events": hasToasts() ? local.topLayer ? "auto" : undefined : "none",
            ...local.style
          };
        }
      }, topLayerAttr, others), false, false);
      return _el$;
    }
  });
}

const _tmpl$ = /*#__PURE__*/web.template(`<li role="status" tabindex="0" aria-atomic="true">`);
const TOAST_SWIPE_START_EVENT = "toast.swipeStart";
const TOAST_SWIPE_MOVE_EVENT = "toast.swipeMove";
const TOAST_SWIPE_CANCEL_EVENT = "toast.swipeCancel";
const TOAST_SWIPE_END_EVENT = "toast.swipeEnd";
function ToastRoot(props) {
  const defaultId = `toast-${solidJs.createUniqueId()}`;
  const rootContext = useToastRegionContext();
  props = utils.mergeDefaultProps({
    id: defaultId,
    priority: "high"
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "toastId", "style", "priority", "duration", "persistent", "onPause", "onResume", "onSwipeStart", "onSwipeMove", "onSwipeCancel", "onSwipeEnd", "onEscapeKeyDown", "onKeyDown", "onPointerDown", "onPointerMove", "onPointerUp"]);
  const [isOpen, setIsOpen] = solidJs.createSignal(true);
  const [titleId, setTitleId] = solidJs.createSignal();
  const [descriptionId, setDescriptionId] = solidJs.createSignal();
  const [isAnimationEnabled, setIsAnimationEnabled] = solidJs.createSignal(true);
  const presence = createPresence(isOpen);
  const duration = solidJs.createMemo(() => local.duration || rootContext.duration());
  let closeTimerId;
  let closeTimerStartTime = 0;
  let closeTimerRemainingTime = duration();
  let pointerStart = null;
  let swipeDelta = null;
  const close = () => {
    setIsOpen(false);

    // Restore animation for the exit phase, which have been disabled if it's a toast update.
    setIsAnimationEnabled(true);
  };
  const deleteToast = () => {
    toastStore.remove(local.toastId);
  };
  const startTimer = duration => {
    if (!duration || local.persistent) {
      return;
    }
    window.clearTimeout(closeTimerId);
    closeTimerStartTime = new Date().getTime();
    closeTimerId = window.setTimeout(close, duration);
  };
  const resumeTimer = () => {
    startTimer(closeTimerRemainingTime);
    local.onResume?.();
  };
  const pauseTimer = () => {
    const elapsedTime = new Date().getTime() - closeTimerStartTime;
    closeTimerRemainingTime = closeTimerRemainingTime - elapsedTime;
    window.clearTimeout(closeTimerId);
    local.onPause?.();
  };
  const onKeyDown = e => {
    utils.callHandler(e, local.onKeyDown);
    if (e.key !== "Escape") {
      return;
    }
    local.onEscapeKeyDown?.(e);
    if (!e.defaultPrevented) {
      close();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    if (e.button !== 0) {
      return;
    }
    pointerStart = {
      x: e.clientX,
      y: e.clientY
    };
  };
  const onPointerMove = e => {
    utils.callHandler(e, local.onPointerMove);
    if (!pointerStart) {
      return;
    }
    const x = e.clientX - pointerStart.x;
    const y = e.clientY - pointerStart.y;
    const hasSwipeMoveStarted = Boolean(swipeDelta);
    const isHorizontalSwipe = ["left", "right"].includes(rootContext.swipeDirection());
    const clamp = ["left", "up"].includes(rootContext.swipeDirection()) ? Math.min : Math.max;
    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;
    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;
    const moveStartBuffer = e.pointerType === "touch" ? 10 : 2;
    const delta = {
      x: clampedX,
      y: clampedY
    };
    const eventDetail = {
      originalEvent: e,
      delta
    };
    if (hasSwipeMoveStarted) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE_EVENT, local.onSwipeMove, eventDetail);
      const {
        x,
        y
      } = delta;
      e.currentTarget.setAttribute("data-swipe", "move");
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-x", `${x}px`);
      e.currentTarget.style.setProperty("--kb-toast-swipe-move-y", `${y}px`);
    } else if (isDeltaInDirection(delta, rootContext.swipeDirection(), moveStartBuffer)) {
      swipeDelta = delta;
      handleAndDispatchCustomEvent(TOAST_SWIPE_START_EVENT, local.onSwipeStart, eventDetail);
      e.currentTarget.setAttribute("data-swipe", "start");
      e.target.setPointerCapture(e.pointerId);
    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
      // User is swiping in wrong direction, so we disable swipe gesture
      // for the current pointer down interaction
      pointerStart = null;
    }
  };
  const onPointerUp = e => {
    utils.callHandler(e, local.onPointerUp);
    const delta = swipeDelta;
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    swipeDelta = null;
    pointerStart = null;
    if (delta) {
      const toast = e.currentTarget;
      const eventDetail = {
        originalEvent: e,
        delta
      };
      if (isDeltaInDirection(delta, rootContext.swipeDirection(), rootContext.swipeThreshold())) {
        handleAndDispatchCustomEvent(TOAST_SWIPE_END_EVENT, local.onSwipeEnd, eventDetail);
        const {
          x,
          y
        } = delta;
        e.currentTarget.setAttribute("data-swipe", "end");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-x", `${x}px`);
        e.currentTarget.style.setProperty("--kb-toast-swipe-end-y", `${y}px`);
        close();
      } else {
        handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL_EVENT, local.onSwipeCancel, eventDetail);
        e.currentTarget.setAttribute("data-swipe", "cancel");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-move-y");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-x");
        e.currentTarget.style.removeProperty("--kb-toast-swipe-end-y");
      }

      // Prevent click event from triggering on items within the toast when
      // pointer up is part of a swipe gesture
      toast.addEventListener("click", event => event.preventDefault(), {
        once: true
      });
    }
  };
  solidJs.onMount(() => {
    // Disable animation for updated toast.
    if (rootContext.toasts().find(toast => toast.id === local.toastId && toast.update)) {
      setIsAnimationEnabled(false);
    }
  });
  solidJs.createEffect(solidJs.on(() => rootContext.isPaused(), isPaused => {
    if (isPaused) {
      pauseTimer();
    } else {
      resumeTimer();
    }
  }, {
    defer: true
  }));

  // start timer when toast opens or duration changes.
  // we include `open` in deps because closed !== unmounted when animating,
  // so it could reopen before being completely unmounted
  solidJs.createEffect(solidJs.on([isOpen, duration], ([isOpen, duration]) => {
    if (isOpen && !rootContext.isPaused()) {
      startTimer(duration);
    }
  }));
  solidJs.createEffect(solidJs.on(() => toastStore.get(local.toastId)?.dismiss, dismiss => dismiss && close()));
  solidJs.createEffect(solidJs.on(() => presence.isPresent(), isPresent => !isPresent && deleteToast()));
  const context = {
    close,
    duration,
    isPersistent: () => local.persistent ?? false,
    closeTimerStartTime: () => closeTimerStartTime,
    generateId: utils.createGenerateId(() => others.id),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return web.createComponent(solidJs.Show, {
    get when() {
      return presence.isPresent();
    },
    get children() {
      return web.createComponent(ToastContext.Provider, {
        value: context,
        get children() {
          const _el$ = _tmpl$();
          _el$.$$pointerup = onPointerUp;
          _el$.$$pointermove = onPointerMove;
          _el$.$$pointerdown = onPointerDown;
          _el$.$$keydown = onKeyDown;
          const _ref$ = utils.mergeRefs(presence.setRef, local.ref);
          typeof _ref$ === "function" && web.use(_ref$, _el$);
          web.spread(_el$, web.mergeProps({
            get style() {
              return {
                animation: isAnimationEnabled() ? undefined : "none",
                "user-select": "none",
                "touch-action": "none",
                ...local.style
              };
            },
            get ["aria-live"]() {
              return local.priority === "high" ? "assertive" : "polite";
            },
            get ["aria-labelledby"]() {
              return titleId();
            },
            get ["aria-describedby"]() {
              return descriptionId();
            },
            get ["data-opened"]() {
              return isOpen() ? "" : undefined;
            },
            get ["data-closed"]() {
              return !isOpen() ? "" : undefined;
            },
            get ["data-swipe-direction"]() {
              return rootContext.swipeDirection();
            }
          }, others), false, false);
          return _el$;
        }
      });
    }
  });
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
}
function handleAndDispatchCustomEvent(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, {
    bubbles: true,
    cancelable: true,
    detail
  });
  if (handler) {
    currentTarget.addEventListener(name, handler, {
      once: true
    });
  }
  currentTarget.dispatchEvent(event);
}
web.delegateEvents(["keydown", "pointerdown", "pointermove", "pointerup"]);

/**
 * An accessible title to be announced when the toast is open.
 */
function ToastTitle(props) {
  const context = useToastContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("title")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerTitleId(local.id)));
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, others));
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CloseButton: ToastCloseButton,
  Description: ToastDescription,
  List: ToastList,
  ProgressFill: ToastProgressFill,
  ProgressTrack: ToastProgressTrack,
  Region: ToastRegion,
  Root: ToastRoot,
  Title: ToastTitle
});

/**
 * A two-state button that allow users to toggle a selection on or off.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */
function ToggleButtonRoot(props) {
  const [local, others] = solidJs.splitProps(props, ["children", "pressed", "defaultPressed", "onChange", "onClick"]);
  const state = createToggleState({
    isSelected: () => local.pressed,
    defaultIsSelected: () => local.defaultPressed,
    onSelectedChange: selected => local.onChange?.(selected),
    isDisabled: () => others.disabled
  });
  const onClick = e => {
    utils.callHandler(e, local.onClick);
    state.toggle();
  };
  return web.createComponent(ButtonRoot, web.mergeProps({
    get ["aria-pressed"]() {
      return state.isSelected();
    },
    get ["data-pressed"]() {
      return state.isSelected() ? "" : undefined;
    },
    onClick: onClick
  }, others, {
    get children() {
      return web.createComponent(ToggleButtonRootChild, {
        get state() {
          return {
            pressed: state.isSelected
          };
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
}
function ToggleButtonRootChild(props) {
  const resolvedChildren = solidJs.children(() => {
    const body = props.children;
    return utils.isFunction(body) ? body(props.state) : body;
  });
  return web.memo(resolvedChildren);
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: ToggleButtonRoot
});

const TooltipContext = solidJs.createContext();
function useTooltipContext() {
  const context = solidJs.useContext(TooltipContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTooltipContext` must be used within a `Tooltip` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the tooltip is open.
 */
function TooltipContent(props) {
  const context = useTooltipContext();
  props = utils.mergeDefaultProps({
    id: context.generateId("content")
  }, props);
  const [local, others] = solidJs.splitProps(props, ["ref", "style"]);
  solidJs.createEffect(() => solidJs.onCleanup(context.registerContentId(others.id)));
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(PopperPositioner, {
        get children() {
          return web.createComponent(DismissableLayer, web.mergeProps({
            ref(r$) {
              const _ref$ = utils.mergeRefs(el => {
                context.setContentRef(el);
                context.contentPresence.setRef(el);
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "tooltip",
            disableOutsidePointerEvents: false,
            get style() {
              return {
                "--kb-tooltip-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            onDismiss: () => context.hideTooltip(true)
          }, () => context.dataset(), others));
        }
      });
    }
  });
}

/**
 * Portals its children into the `body` when the tooltip is open.
 */
function TooltipPortal(props) {
  const context = useTooltipContext();
  return web.createComponent(solidJs.Show, {
    get when() {
      return context.contentPresence.isPresent();
    },
    get children() {
      return web.createComponent(web.Portal, props);
    }
  });
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */

/**
 * Construct a polygon based on the floating element placement relative to the anchor.
 */
function getTooltipSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

const tooltips = {};
let tooltipsCounter = 0;
let globalWarmedUp = false;
let globalWarmUpTimeout;
let globalCoolDownTimeout;
/**
 * A popup that displays information related to an element
 * when the element receives keyboard focus or the mouse hovers over it.
 */
function TooltipRoot(props) {
  const defaultId = `tooltip-${solidJs.createUniqueId()}`;

  // This is not the DOM id.
  const tooltipId = `${++tooltipsCounter}`;
  props = utils.mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = solidJs.splitProps(props, ["id", "open", "defaultOpen", "onOpenChange", "disabled", "triggerOnFocusOnly", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let closeTimeoutId;
  const [contentId, setContentId] = solidJs.createSignal();
  const [triggerRef, setTriggerRef] = solidJs.createSignal();
  const [contentRef, setContentRef] = solidJs.createSignal();
  const [currentPlacement, setCurrentPlacement] = solidJs.createSignal(others.placement);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const contentPresence = createPresence(() => local.forceMount || disclosureState.isOpen());
  const ensureTooltipEntry = () => {
    tooltips[tooltipId] = hideTooltip;
  };
  const closeOpenTooltips = () => {
    for (const hideTooltipId in tooltips) {
      if (hideTooltipId !== tooltipId) {
        tooltips[hideTooltipId](true);
        delete tooltips[hideTooltipId];
      }
    }
  };
  const hideTooltip = (immediate = false) => {
    if (web.isServer) {
      return;
    }
    if (immediate || local.closeDelay && local.closeDelay <= 0) {
      window.clearTimeout(closeTimeoutId);
      closeTimeoutId = undefined;
      disclosureState.close();
    } else if (!closeTimeoutId) {
      closeTimeoutId = window.setTimeout(() => {
        closeTimeoutId = undefined;
        disclosureState.close();
      }, local.closeDelay);
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    if (globalWarmedUp) {
      window.clearTimeout(globalCoolDownTimeout);
      globalCoolDownTimeout = window.setTimeout(() => {
        delete tooltips[tooltipId];
        globalCoolDownTimeout = undefined;
        globalWarmedUp = false;
      }, local.closeDelay);
    }
  };
  const showTooltip = () => {
    if (web.isServer) {
      return;
    }
    clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
    closeOpenTooltips();
    ensureTooltipEntry();
    globalWarmedUp = true;
    disclosureState.open();
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    window.clearTimeout(globalCoolDownTimeout);
    globalCoolDownTimeout = undefined;
  };
  const warmupTooltip = () => {
    if (web.isServer) {
      return;
    }
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!disclosureState.isOpen() && !globalWarmUpTimeout && !globalWarmedUp) {
      globalWarmUpTimeout = window.setTimeout(() => {
        globalWarmUpTimeout = undefined;
        globalWarmedUp = true;
        showTooltip();
      }, local.openDelay);
    } else if (!disclosureState.isOpen()) {
      showTooltip();
    }
  };
  const openTooltip = (immediate = false) => {
    if (web.isServer) {
      return;
    }
    if (!immediate && local.openDelay && local.openDelay > 0 && !closeTimeoutId) {
      warmupTooltip();
    } else {
      showTooltip();
    }
  };
  const cancelOpening = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(globalWarmUpTimeout);
    globalWarmUpTimeout = undefined;
    globalWarmedUp = false;
  };
  const cancelClosing = () => {
    if (web.isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnTooltip = target => {
    return utils.contains(triggerRef(), target) || utils.contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getTooltipSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;

    // Don't close if the mouse is moving through valid tooltip element.
    if (isTargetOnTooltip(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());

      //Don't close if the current's event mouse position is inside the polygon safe area.
      if (polygon && utils.isPointInPolygon(utils.getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }

    // If there's already a scheduled timeout to hide the tooltip, we do nothing.
    if (closeTimeoutId) {
      return;
    }

    // Otherwise, hide the tooltip after the close delay.
    hideTooltip();
  };
  solidJs.createEffect(() => {
    if (!disclosureState.isOpen()) {
      return;
    }
    const doc = utils.getDocument();

    // Checks whether the mouse is moving outside the tooltip.
    // If yes, hide the tooltip after the close delay.
    doc.addEventListener("pointermove", onHoverOutside, true);
    solidJs.onCleanup(() => {
      doc.removeEventListener("pointermove", onHoverOutside, true);
    });
  });

  // Close the tooltip if the trigger is scrolled.
  solidJs.createEffect(() => {
    const trigger = triggerRef();
    if (!trigger || !disclosureState.isOpen()) {
      return;
    }
    const handleScroll = event => {
      const target = event.target;
      if (utils.contains(target, trigger)) {
        hideTooltip(true);
      }
    };
    const win = utils.getWindow();
    win.addEventListener("scroll", handleScroll, {
      capture: true
    });
    solidJs.onCleanup(() => {
      win.removeEventListener("scroll", handleScroll, {
        capture: true
      });
    });
  });
  solidJs.onCleanup(() => {
    clearTimeout(closeTimeoutId);
    const tooltip = tooltips[tooltipId];
    if (tooltip) {
      delete tooltips[tooltipId];
    }
  });
  const dataset = solidJs.createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : undefined,
    "data-closed": !disclosureState.isOpen() ? "" : undefined
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    isDisabled: () => local.disabled ?? false,
    triggerOnFocusOnly: () => local.triggerOnFocusOnly ?? false,
    contentId,
    contentPresence,
    openTooltip,
    hideTooltip,
    cancelOpening,
    generateId: utils.createGenerateId(() => props.id),
    registerContentId: createRegisterId(setContentId),
    isTargetOnTooltip,
    setTriggerRef,
    setContentRef
  };
  return web.createComponent(TooltipContext.Provider, {
    value: context,
    get children() {
      return web.createComponent(PopperRoot, web.mergeProps({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
}

/**
 * The button that opens the tooltip when hovered.
 */
function TooltipTrigger(props) {
  let ref;
  const context = useTooltipContext();
  const [local, others] = solidJs.splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onPointerDown", "onClick", "onFocus", "onBlur", "onTouchStart"]);
  let isPointerDown = false;
  let isHovered = false;
  let isFocused = false;
  const handlePointerUp = () => {
    isPointerDown = false;
  };
  const handleShow = () => {
    if (!context.isOpen() && (isHovered || isFocused)) {
      context.openTooltip(isFocused);
    }
  };
  const handleHide = immediate => {
    if (context.isOpen() && !isHovered && !isFocused) {
      context.hideTooltip(immediate);
    }
  };
  const onPointerEnter = e => {
    utils.callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || context.triggerOnFocusOnly() || context.isDisabled() || e.defaultPrevented) {
      return;
    }
    isHovered = true;
    handleShow();
  };
  const onPointerLeave = e => {
    utils.callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }

    // No matter how the trigger is left, we should close the tooltip.
    isHovered = false;
    isFocused = false;
    if (context.isOpen()) {
      handleHide();
    } else {
      context.cancelOpening();
    }
  };
  const onPointerDown = e => {
    utils.callHandler(e, local.onPointerDown);
    isPointerDown = true;
    utils.getDocument(ref).addEventListener("pointerup", handlePointerUp, {
      once: true
    });
  };
  const onClick = e => {
    utils.callHandler(e, local.onClick);

    // No matter how the trigger is left, we should close the tooltip.
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  const onFocus = e => {
    utils.callHandler(e, local.onFocus);
    if (context.isDisabled() || e.defaultPrevented || isPointerDown) {
      return;
    }
    isFocused = true;
    handleShow();
  };
  const onBlur = e => {
    utils.callHandler(e, local.onBlur);
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnTooltip(relatedTarget)) {
      return;
    }

    // No matter how the trigger is left, we should close the tooltip.
    isHovered = false;
    isFocused = false;
    handleHide(true);
  };
  solidJs.onCleanup(() => {
    utils.getDocument(ref).removeEventListener("pointerup", handlePointerUp);
  });

  // We purposefully avoid using Kobalte `Button` here because tooltip triggers can be any element
  // and should not always be announced as a button to screen readers.
  return web.createComponent(Polymorphic, web.mergeProps({
    as: "button",
    ref(r$) {
      const _ref$ = utils.mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["aria-describedby"]() {
      return web.memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onPointerDown: onPointerDown,
    onClick: onClick,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => context.dataset(), others));
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: TooltipContent,
  Portal: TooltipPortal,
  Root: TooltipRoot,
  Trigger: TooltipTrigger
});

exports.Accordion = index$n;
exports.Alert = index$m;
exports.AlertDialog = index$k;
exports.As = As;
exports.Breadcrumbs = index$i;
exports.Button = index$p;
exports.COLOR_MODE_STORAGE_KEY = COLOR_MODE_STORAGE_KEY;
exports.COMMON_INTL_MESSAGES = COMMON_INTL_MESSAGES;
exports.Checkbox = index$h;
exports.Collapsible = index$o;
exports.ColorModeContext = ColorModeContext;
exports.ColorModeProvider = ColorModeProvider;
exports.ColorModeScript = ColorModeScript;
exports.Combobox = index$f;
exports.ContextMenu = index$d;
exports.DATA_LIVE_ANNOUNCER_ATTR = DATA_LIVE_ANNOUNCER_ATTR;
exports.Dialog = index$l;
exports.DropdownMenu = index$c;
exports.FORM_CONTROL_FIELD_PROP_NAMES = FORM_CONTROL_FIELD_PROP_NAMES;
exports.FORM_CONTROL_PROP_NAMES = FORM_CONTROL_PROP_NAMES;
exports.FormControlContext = FormControlContext;
exports.FormControlDescription = FormControlDescription;
exports.FormControlErrorMessage = FormControlErrorMessage;
exports.FormControlLabel = FormControlLabel;
exports.HoverCard = index$b;
exports.I18nProvider = I18nProvider;
exports.Image = index$a;
exports.Link = index$j;
exports.ListCollection = ListCollection;
exports.ListKeyboardDelegate = ListKeyboardDelegate;
exports.Listbox = index$g;
exports.Polymorphic = Polymorphic;
exports.Popover = index$9;
exports.Progress = index$8;
exports.RTL_LANGS = RTL_LANGS;
exports.RadioGroup = index$7;
exports.Select = index$6;
exports.Selection = Selection;
exports.SelectionManager = SelectionManager;
exports.Separator = index$e;
exports.Switch = index$5;
exports.Tabs = index$4;
exports.TextField = index$3;
exports.Toast = index$2;
exports.ToggleButton = index$1;
exports.Tooltip = index;
exports.announce = announce;
exports.ariaHideOutside = ariaHideOutside;
exports.clearAnnouncer = clearAnnouncer;
exports.cookieStorageManager = cookieStorageManager;
exports.cookieStorageManagerSSR = cookieStorageManagerSSR;
exports.createCollator = createCollator;
exports.createCollection = createCollection;
exports.createControllableArraySignal = createControllableArraySignal;
exports.createControllableBooleanSignal = createControllableBooleanSignal;
exports.createControllableSetSignal = createControllableSetSignal;
exports.createControllableSignal = createControllableSignal;
exports.createCookieStorageManager = createCookieStorageManager;
exports.createDateFormatter = createDateFormatter;
exports.createDefaultLocale = createDefaultLocale;
exports.createDisclosureState = createDisclosureState;
exports.createEscapeKeyDown = createEscapeKeyDown;
exports.createFilter = createFilter;
exports.createFocusScope = createFocusScope;
exports.createFormControl = createFormControl;
exports.createFormControlField = createFormControlField;
exports.createFormResetListener = createFormResetListener;
exports.createHideOutside = createHideOutside;
exports.createInteractOutside = createInteractOutside;
exports.createListState = createListState;
exports.createLocalStorageManager = createLocalStorageManager;
exports.createMessageFormatter = createMessageFormatter;
exports.createMultipleSelectionState = createMultipleSelectionState;
exports.createNumberFormatter = createNumberFormatter;
exports.createPresence = createPresence;
exports.createPreventScroll = createPreventScroll;
exports.createRegisterId = createRegisterId;
exports.createSelectableCollection = createSelectableCollection;
exports.createSelectableItem = createSelectableItem;
exports.createSelectableList = createSelectableList;
exports.createSingleSelectListState = createSingleSelectListState;
exports.createTagName = createTagName;
exports.createToggleState = createToggleState;
exports.createTransition = createTransition;
exports.createTypeSelect = createTypeSelect;
exports.destroyAnnouncer = destroyAnnouncer;
exports.getDefaultLocale = getDefaultLocale;
exports.getItemCount = getItemCount;
exports.getReadingDirection = getReadingDirection;
exports.isRTL = isRTL;
exports.localStorageManager = localStorageManager;
exports.toaster = toaster;
exports.useColorMode = useColorMode;
exports.useColorModeValue = useColorModeValue;
exports.useFormControlContext = useFormControlContext;
exports.useLocale = useLocale;
//# sourceMappingURL=index.js.map
